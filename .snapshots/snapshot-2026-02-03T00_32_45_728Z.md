Enter your prompt here

# Project Structure

â”œâ”€ ðŸ“ levels
  â””â”€ debug.json
  â””â”€ level1.json
â”œâ”€ ðŸ“ css
  â””â”€ editor.css
  â””â”€ style.css
â”œâ”€ ðŸ“ js
  â””â”€ game.js
  â””â”€ editor.js
â””â”€ editor.html
â””â”€ index.html


# Project Files

- c:\Users\jsamu\Cursor projects\AI Generated Space Jam\js\editor.js
- c:\Users\jsamu\Cursor projects\AI Generated Space Jam\levels\level1.json
- c:\Users\jsamu\Cursor projects\AI Generated Space Jam\levels\debug.json
- c:\Users\jsamu\.cursor\plans\unified_dom_hotbar_refactor_94b4aa43.plan.md
- c:\Users\jsamu\Cursor projects\AI Generated Space Jam\index.html
- c:\Users\jsamu\Cursor projects\AI Generated Space Jam\css\style.css
- c:\Users\jsamu\Cursor projects\AI Generated Space Jam\js\game.js

## c:\Users\jsamu\Cursor projects\AI Generated Space Jam\js\editor.js
```
const canvas = document.getElementById('editor-canvas');
const ctx = canvas.getContext('2d');

// Mouse tracking (must be defined before first render)
let mouseX = 0;
let mouseY = 0;
let mouseInCanvas = false;

// Level data
let levelWidth = 5000;
let levelHeight = 5000;
let levelSeed = 12345;
let asteroids = [];
let structures = [];
let selectedTool = 'asteroid';

// Camera
let camX = 0;
let camY = 0;
let zoom = 0.15;

// Panning state
let isPanning = false;
let panStartX = 0;
let panStartY = 0;
let panCamStartX = 0;
let panCamStartY = 0;

// Current tool
let currentAsteroidSize = 40;

const STORAGE_KEY = 'spacejam-level-editor';

function saveLevel() {
  const level = { width: levelWidth, height: levelHeight, seed: levelSeed, asteroids, structures };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(level));
}

function loadLevel() {
  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (!stored) return;
    const level = JSON.parse(stored);
    levelWidth = level.width || 5000;
    levelHeight = level.height || 5000;
    levelSeed = level.seed != null ? (level.seed >>> 0) : 12345;
    asteroids = level.asteroids || [];
    structures = level.structures || [];
    document.getElementById('level-width').value = levelWidth;
    document.getElementById('level-height').value = levelHeight;
  } catch (e) { /* ignore invalid stored data */ }
}

// Resize canvas to fill container
function resizeCanvas() {
  const container = document.getElementById('editor-container');
  const w = container.clientWidth || window.innerWidth - 240;
  const h = container.clientHeight || window.innerHeight;
  if (w > 0 && h > 0) {
    canvas.width = w;
    canvas.height = h;
  }
  render();
}

window.addEventListener('resize', resizeCanvas);
window.addEventListener('load', resizeCanvas);
// Delay initial resize to ensure layout is ready
setTimeout(resizeCanvas, 100);
resizeCanvas();

// Convert screen to world coordinates
function screenToWorld(sx, sy) {
  return {
    x: (sx - canvas.width / 2) / zoom + camX,
    y: (sy - canvas.height / 2) / zoom + camY
  };
}

// Convert world to screen coordinates
function worldToScreen(wx, wy) {
  return {
    x: (wx - camX) * zoom + canvas.width / 2,
    y: (wy - camY) * zoom + canvas.height / 2
  };
}

// Render
function render() {
  ctx.fillStyle = '#0a0a12';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw level bounds
  const topLeft = worldToScreen(-levelWidth / 2, -levelHeight / 2);
  const bottomRight = worldToScreen(levelWidth / 2, levelHeight / 2);
  ctx.strokeStyle = '#335';
  ctx.lineWidth = 2;
  ctx.strokeRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);

  // Draw grid
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 1;
  const gridSize = 500;
  const startX = Math.floor(-levelWidth / 2 / gridSize) * gridSize;
  const startY = Math.floor(-levelHeight / 2 / gridSize) * gridSize;
  for (let gx = startX; gx <= levelWidth / 2; gx += gridSize) {
    const s1 = worldToScreen(gx, -levelHeight / 2);
    const s2 = worldToScreen(gx, levelHeight / 2);
    ctx.beginPath();
    ctx.moveTo(s1.x, s1.y);
    ctx.lineTo(s2.x, s2.y);
    ctx.stroke();
  }
  for (let gy = startY; gy <= levelHeight / 2; gy += gridSize) {
    const s1 = worldToScreen(-levelWidth / 2, gy);
    const s2 = worldToScreen(levelWidth / 2, gy);
    ctx.beginPath();
    ctx.moveTo(s1.x, s1.y);
    ctx.lineTo(s2.x, s2.y);
    ctx.stroke();
  }

  // Draw origin crosshair
  const origin = worldToScreen(0, 0);
  ctx.strokeStyle = '#444';
  ctx.beginPath();
  ctx.moveTo(origin.x - 15, origin.y);
  ctx.lineTo(origin.x + 15, origin.y);
  ctx.moveTo(origin.x, origin.y - 15);
  ctx.lineTo(origin.x, origin.y + 15);
  ctx.stroke();

  const STRUCTURE_SIZE = 80;
  const STRUCTURE_STYLES = {
    shop: { fill: '#446688', stroke: '#6699bb' },
    shipyard: { fill: '#664466', stroke: '#886688' },
    refinery: { fill: '#666644', stroke: '#888866' },
    fueling: { fill: '#446644', stroke: '#668866' },
    warpgate: { fill: '#6644aa', stroke: '#8866cc' },
    piratebase: { fill: '#884422', stroke: '#aa6644' }
  };

  // Draw asteroids
  for (const ast of asteroids) {
    const s = worldToScreen(ast.x, ast.y);
    const r = ast.radius * zoom;
    ctx.fillStyle = '#665544';
    ctx.strokeStyle = '#998877';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
  }

  // Draw structures
  for (const st of structures) {
    const s = worldToScreen(st.x, st.y);
    const r = STRUCTURE_SIZE * zoom;
    const style = STRUCTURE_STYLES[st.type] || STRUCTURE_STYLES.shop;
    ctx.fillStyle = style.fill;
    ctx.strokeStyle = style.stroke;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(s.x - r, s.y - r * 0.6, r * 2, r * 1.2);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = '#fff';
    ctx.font = `${Math.max(8, r * 0.4)}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
      const label = st.type === 'warpgate' ? 'W' : (st.type === 'piratebase' ? 'P' : st.type.charAt(0).toUpperCase());
      ctx.fillText(label, s.x, s.y);
  }

  // Draw viewport scale box at mouse (1200x900 = game screen size in world units)
  const GAME_VIEW_WIDTH = 1200;
  const GAME_VIEW_HEIGHT = 900;
  if (mouseInCanvas) {
    const boxW = GAME_VIEW_WIDTH * zoom;
    const boxH = GAME_VIEW_HEIGHT * zoom;
    ctx.strokeStyle = 'rgba(100, 150, 255, 0.8)';
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 4]);
    ctx.strokeRect(mouseX - boxW / 2, mouseY - boxH / 2, boxW, boxH);
    ctx.setLineDash([]);
  }

  // Draw preview at mouse (if in bounds)
  if (mouseInCanvas) {
    const world = screenToWorld(mouseX, mouseY);
    const s = worldToScreen(world.x, world.y);
    if (selectedTool === 'asteroid') {
      const r = currentAsteroidSize * zoom;
      ctx.fillStyle = 'rgba(102, 85, 68, 0.5)';
      ctx.strokeStyle = '#aaa';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
    } else if (STRUCTURE_STYLES[selectedTool]) {
      const r = STRUCTURE_SIZE * zoom;
      const style = STRUCTURE_STYLES[selectedTool];
      ctx.fillStyle = style.fill + '99';
      ctx.strokeStyle = style.stroke;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.rect(s.x - r, s.y - r * 0.6, r * 2, r * 1.2);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.font = `${Math.max(8, r * 0.4)}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const label = selectedTool === 'warpgate' ? 'W' : (selectedTool === 'piratebase' ? 'P' : selectedTool.charAt(0).toUpperCase());
      ctx.fillText(label, s.x, s.y);
    }
  }

  // Info
  ctx.fillStyle = '#666';
  ctx.font = '12px Arial';
  ctx.fillText(`Asteroids: ${asteroids.length} | Structures: ${structures.length} | Zoom: ${(zoom * 100).toFixed(0)}%`, 10, 20);
}

canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = e.clientY - rect.top;

  if (isPanning) {
    camX = panCamStartX - (mouseX - panStartX) / zoom;
    camY = panCamStartY - (mouseY - panStartY) / zoom;
  }

  render();
});

canvas.addEventListener('mouseenter', () => { mouseInCanvas = true; render(); });
canvas.addEventListener('mouseleave', () => { mouseInCanvas = false; isPanning = false; render(); });

// Place/remove asteroids
canvas.addEventListener('mousedown', (e) => {
  e.preventDefault();
  canvas.focus();
  
  // Update mouse position from event
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = e.clientY - rect.top;

  if (e.button === 0) {
    // Left click - place selected object
    const world = screenToWorld(mouseX, mouseY);
    if (selectedTool === 'asteroid') {
      asteroids.push({ x: world.x, y: world.y, radius: currentAsteroidSize });
    } else if (['shop', 'shipyard', 'refinery', 'fueling', 'warpgate', 'piratebase'].includes(selectedTool)) {
      structures.push({ x: world.x, y: world.y, type: selectedTool });
    }
    saveLevel();
    render();
  } else if (e.button === 2) {
    // Right click - remove object under cursor
    const world = screenToWorld(mouseX, mouseY);
    for (let i = asteroids.length - 1; i >= 0; i--) {
      const a = asteroids[i];
      const dx = a.x - world.x;
      const dy = a.y - world.y;
      if (Math.sqrt(dx * dx + dy * dy) < a.radius) {
        asteroids.splice(i, 1);
        saveLevel();
        render();
        return;
      }
    }
    const structHalfW = 80;
    const structHalfH = 48;
    for (let i = structures.length - 1; i >= 0; i--) {
      const st = structures[i];
      const dx = st.x - world.x;
      const dy = st.y - world.y;
      if (Math.abs(dx) < structHalfW && Math.abs(dy) < structHalfH) {
        structures.splice(i, 1);
        saveLevel();
        break;
      }
    }
    render();
  } else if (e.button === 1) {
    // Middle click - pan
    e.preventDefault();
    isPanning = true;
    panStartX = mouseX;
    panStartY = mouseY;
    panCamStartX = camX;
    panCamStartY = camY;
  }
});

canvas.addEventListener('mouseup', (e) => {
  if (e.button === 1) isPanning = false;
});

canvas.addEventListener('contextmenu', (e) => e.preventDefault());

// Zoom
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
  zoom = Math.max(0.02, Math.min(2, zoom * zoomFactor));
  render();
});

// Toolbar controls
document.getElementById('asteroid-size').addEventListener('input', (e) => {
  currentAsteroidSize = parseInt(e.target.value);
  document.getElementById('size-display').textContent = currentAsteroidSize;
  render();
});

function updateAsteroidSizeFromValue() {
  document.getElementById('asteroid-size').value = currentAsteroidSize;
  document.getElementById('size-display').textContent = currentAsteroidSize;
  render();
}

window.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowUp') {
    e.preventDefault();
    currentAsteroidSize = Math.min(300, currentAsteroidSize + 10);
    updateAsteroidSizeFromValue();
  } else if (e.key === 'ArrowDown') {
    e.preventDefault();
    currentAsteroidSize = Math.max(10, currentAsteroidSize - 10);
    updateAsteroidSizeFromValue();
  }
});

// Tool palette selection
document.querySelectorAll('.palette-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    selectedTool = btn.dataset.tool;
    document.querySelectorAll('.palette-btn').forEach(b => b.classList.remove('selected'));
    btn.classList.add('selected');
    render();
  });
});

document.getElementById('apply-size').addEventListener('click', () => {
  levelWidth = parseInt(document.getElementById('level-width').value) || 5000;
  levelHeight = parseInt(document.getElementById('level-height').value) || 5000;
  saveLevel();
  render();
});

document.getElementById('clear-all').addEventListener('click', () => {
  if (confirm('Clear all asteroids and structures?')) {
    asteroids = [];
    structures = [];
    saveLevel();
    render();
  }
});

document.getElementById('export-level').addEventListener('click', () => {
  const level = {
    width: levelWidth,
    height: levelHeight,
    seed: levelSeed,
    asteroids,
    structures
  };
  const json = JSON.stringify(level, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'level.json';
  a.click();
  URL.revokeObjectURL(url);
});

document.getElementById('import-level').addEventListener('click', () => {
  document.getElementById('import-file').click();
});

document.getElementById('import-file').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const level = JSON.parse(ev.target.result);
      levelWidth = level.width || 5000;
      levelHeight = level.height || 5000;
      levelSeed = level.seed != null ? (level.seed >>> 0) : 12345;
      asteroids = level.asteroids || [];
      structures = level.structures || [];
      document.getElementById('level-width').value = levelWidth;
      document.getElementById('level-height').value = levelHeight;
      saveLevel();
      render();
    } catch (err) {
      alert('Invalid level file');
    }
  };
  reader.readAsText(file);
  e.target.value = '';
});

// Load saved level on startup
loadLevel();

// Initial render
render();

```

## c:\Users\jsamu\Cursor projects\AI Generated Space Jam\levels\level1.json
```
{
  "width": 3000,
  "height": 3000,
  "seed": 4242,
  "asteroids": [
    {
      "x": -215.0157472571609,
      "y": -253.41141641022537,
      "radius": 30
    },
    {
      "x": -130.54527512041912,
      "y": -307.1653532245156,
      "radius": 30
    },
    {
      "x": -211.1761803418545,
      "y": -357.0797231234994,
      "radius": 30
    },
    {
      "x": -341.7214554622736,
      "y": -238.0531487489996,
      "radius": 30
    },
    {
      "x": -426.1919275990154,
      "y": -299.48621939390273,
      "radius": 30
    },
    {
      "x": -380.11712461533807,
      "y": -418.5127937684025,
      "radius": 30
    },
    {
      "x": -142.06397586633847,
      "y": -433.8710614296283,
      "radius": 30
    },
    {
      "x": -314.84448705512847,
      "y": -337.88188854696716,
      "radius": 40
    },
    {
      "x": -241.89271566430602,
      "y": -460.7480298367734,
      "radius": 40
    },
    {
      "x": -145.90354278164492,
      "y": -518.3415335663701,
      "radius": 40
    },
    {
      "x": -334.04232163166074,
      "y": -506.82283282045074,
      "radius": 30
    },
    {
      "x": 46.074802983677344,
      "y": -368.59842386941875,
      "radius": 30
    },
    {
      "x": -42.235236068370895,
      "y": -426.1919275990154,
      "radius": 30
    },
    {
      "x": -46.074802983677344,
      "y": -549.0580688888216,
      "radius": 30
    },
    {
      "x": -30.71653532245156,
      "y": -307.1653532245156,
      "radius": 50
    },
    {
      "x": 64.25721490492191,
      "y": -508.9171420469815,
      "radius": 60
    },
    {
      "x": 478.2713102709257,
      "y": -59.11218441550768,
      "radius": 110
    },
    {
      "x": 91.35519409669368,
      "y": 429.90679574914674,
      "radius": 140
    },
    {
      "x": -338.55160165245303,
      "y": 419.15912585541804,
      "radius": 20
    },
    {
      "x": -462.1498054303327,
      "y": 521.2619898458404,
      "radius": 20
    },
    {
      "x": -494.39281511151876,
      "y": 403.03762101482505,
      "radius": 20
    },
    {
      "x": -591.1218441550767,
      "y": 478.2713102709257,
      "radius": 30
    },
    {
      "x": 974.6583192261886,
      "y": -1042.395190832642,
      "radius": 60
    },
    {
      "x": 914.447766687119,
      "y": -760.1582258057533,
      "radius": 50
    },
    {
      "x": 1283.2374009889202,
      "y": -884.3424904175843,
      "radius": 70
    },
    {
      "x": 1140.23733870863,
      "y": -361.2633152344174,
      "radius": 90
    },
    {
      "x": 1019.8162336304908,
      "y": 677.3687160645326,
      "radius": 140
    },
    {
      "x": 184.39481715090054,
      "y": 1034.8688717652583,
      "radius": 70
    },
    {
      "x": -86.5526692749125,
      "y": 1287.000560522612,
      "radius": 70
    },
    {
      "x": -116.65794554444729,
      "y": 1031.1057122315663,
      "radius": 40
    },
    {
      "x": 116.65794554444729,
      "y": 1241.8426461183099,
      "radius": 40
    },
    {
      "x": 56.44739300537772,
      "y": 1147.7636577760136,
      "radius": 40
    },
    {
      "x": 372.55279383549293,
      "y": 989.7109573609561,
      "radius": 40
    },
    {
      "x": 222.02641248781902,
      "y": 888.1056499512761,
      "radius": 40
    },
    {
      "x": -391.3685915039522,
      "y": 1136.4741791749382,
      "radius": 40
    },
    {
      "x": -867.3401847248717,
      "y": -475.9793696660882,
      "radius": 50
    },
    {
      "x": -1135.2989409813363,
      "y": -800.3504956607557,
      "radius": 50
    },
    {
      "x": 250.329890713276,
      "y": -1163.5051258504377,
      "radius": 50
    },
    {
      "x": -997.7937897444663,
      "y": -1216.3917224800032,
      "radius": 60
    },
    {
      "x": 56.41236973820304,
      "y": -821.5051343125818,
      "radius": 60
    },
    {
      "x": 581.7525629252189,
      "y": 320.8453528860298,
      "radius": 30
    },
    {
      "x": 1092.989663677684,
      "y": 56.41236973820304,
      "radius": 30
    },
    {
      "x": -1071.8350250258577,
      "y": -91.67010082457995,
      "radius": 30
    },
    {
      "x": -1145.8762603072494,
      "y": 35.2577310863769,
      "radius": 30
    },
    {
      "x": -1005.4982569077856,
      "y": 21.76403153480055,
      "radius": 30
    },
    {
      "x": -1057.7319325913068,
      "y": 100.11454506008258,
      "radius": 30
    },
    {
      "x": -1079.4959641261075,
      "y": 0,
      "radius": 10
    },
    {
      "x": -1170.9048965722698,
      "y": -56.58648199048139,
      "radius": 10
    },
    {
      "x": -1118.6712208887484,
      "y": -47.88086937656118,
      "radius": 10
    },
    {
      "x": -1014.2038695217058,
      "y": -43.5280630696011,
      "radius": 10
    },
    {
      "x": -983.7342253729851,
      "y": 82.70331983224213,
      "radius": 10
    },
    {
      "x": -1118.6712208887484,
      "y": 108.82015767400279,
      "radius": 10
    },
    {
      "x": -1197.0217344140306,
      "y": 60.93928829744158,
      "radius": 10
    },
    {
      "x": -1223.1385722557911,
      "y": -8.70561261392021,
      "radius": 10
    },
    {
      "x": -1018.5566758286659,
      "y": -91.40893244616228,
      "radius": 10
    },
    {
      "x": -957.6173875312244,
      "y": -21.76403153480055,
      "radius": 10
    },
    {
      "x": -1136.082446116589,
      "y": -78.35051352528194,
      "radius": 10
    },
    {
      "x": -1114.3184145817884,
      "y": -130.5841892088033,
      "radius": 10
    },
    {
      "x": -1192.6689281070703,
      "y": -100.11454506008255,
      "radius": 20
    },
    {
      "x": -970.6758064521047,
      "y": -65.29209460440165,
      "radius": 20
    },
    {
      "x": -1170.9048965722698,
      "y": 134.93699551576347,
      "radius": 20
    },
    {
      "x": -1109.9656082748284,
      "y": 191.5234775062449,
      "radius": 20
    },
    {
      "x": -861.8556487781019,
      "y": 948.9117749173042,
      "radius": 180
    },
    {
      "x": -1292.7834731671528,
      "y": -1240.5497974836314,
      "radius": 30
    },
    {
      "x": -1005.4982569077856,
      "y": -1375.486792999395,
      "radius": 30
    },
    {
      "x": 126.2313829018432,
      "y": -1044.6735136704265,
      "radius": 30
    },
    {
      "x": 282.9324099524072,
      "y": -848.7972298572215,
      "radius": 30
    },
    {
      "x": -887.9724866198626,
      "y": -700.8018154205779,
      "radius": 30
    }
  ],
  "structures": [
    {
      "x": -432.7633463745625,
      "y": 7.526319067383696,
      "type": "warpgate"
    },
    {
      "x": 835.4214164795902,
      "y": 1072.5004671021766,
      "type": "shop"
    },
    {
      "x": -514.7628738611028,
      "y": -1078.8865712431332,
      "type": "piratebase"
    }
  ]
}
```

## c:\Users\jsamu\Cursor projects\AI Generated Space Jam\levels\debug.json
```
{
  "width": 5000,
  "height": 5000,
  "seed": 1337,
  "asteroids": [
    {
      "x": -478.66600877487025,
      "y": 295.64665247859637,
      "radius": 10
    },
    {
      "x": -337.8818885469673,
      "y": 295.64665247859637,
      "radius": 20
    },
    {
      "x": -178.32655228867716,
      "y": 305.03226049378986,
      "radius": 30
    },
    {
      "x": -23.464020037983836,
      "y": 295.64665247859637,
      "radius": 40
    },
    {
      "x": 164.24814026588686,
      "y": 272.1826324406125,
      "radius": 50
    },
    {
      "x": 389.5027326305317,
      "y": 229.9473963722416,
      "radius": 60
    },
    {
      "x": 586.6005009495959,
      "y": 178.32655228867716,
      "radius": 70
    },
    {
      "x": 821.2407013294343,
      "y": 107.93449217472565,
      "radius": 80
    },
    {
      "x": 1074.6521177396596,
      "y": 0,
      "radius": 90
    },
    {
      "x": 1313.9851221270949,
      "y": -211.17618034185452,
      "radius": 100
    },
    {
      "x": 1604.9389705980943,
      "y": -450.50918472928964,
      "radius": 110
    },
    {
      "x": 1816.115150939949,
      "y": -736.7702291926925,
      "radius": 120
    },
    {
      "x": 1769.1871108639814,
      "y": -1093.4233337700468,
      "radius": 130
    },
    {
      "x": 1497.0044784233687,
      "y": -1426.6124183094173,
      "radius": 140
    },
    {
      "x": 1210.743433959966,
      "y": -1572.0893425449171,
      "radius": 150
    },
    {
      "x": 807.162289306644,
      "y": -1572.0893425449171,
      "radius": 160
    },
    {
      "x": 422.35236068370904,
      "y": -1572.0893425449171,
      "radius": 170
    },
    {
      "x": -32.84962805317737,
      "y": -1567.3965385373203,
      "radius": 180
    },
    {
      "x": -469.28040075967675,
      "y": -1529.8541064765461,
      "radius": 190
    },
    {
      "x": -915.0967814813696,
      "y": -1487.6188704081753,
      "radius": 200
    },
    {
      "x": -1281.1354940739175,
      "y": -1135.6585698384176,
      "radius": 210
    },
    {
      "x": -1487.6188704081753,
      "y": -642.9141490407571,
      "radius": 220
    },
    {
      "x": -1745.7230908259974,
      "y": -136.09131622030625,
      "radius": 230
    },
    {
      "x": -1689.4094427348361,
      "y": 422.35236068370904,
      "radius": 240
    },
    {
      "x": -1304.5995141119013,
      "y": 980.7960375877244,
      "radius": 250
    },
    {
      "x": -558.4436769040153,
      "y": 1177.8938059067887,
      "radius": 260
    },
    {
      "x": 244.0258083950319,
      "y": 1220.1290419751595,
      "radius": 270
    },
    {
      "x": 1051.1880977016758,
      "y": 1238.9002580055467,
      "radius": 280
    },
    {
      "x": 1783.2655228867716,
      "y": 877.5543494205955,
      "radius": 290
    },
    {
      "x": 2078.912175365368,
      "y": 28.156824045580603,
      "radius": 300
    }
  ],
  "structures": [
    {
      "x": -647.0552671883593,
      "y": -851.8195922479665,
      "type": "shop"
    },
    {
      "x": -122.85859503576441,
      "y": -876.3913112551195,
      "type": "shop"
    },
    {
      "x": 401.3380771168304,
      "y": -909.1536032646567,
      "type": "shop"
    },
    {
      "x": 1122.1085013266484,
      "y": -991.0593332884996,
      "type": "shop"
    },
    {
      "x": 1187.6330853457225,
      "y": -573.3401101669006,
      "type": "shop"
    },
    {
      "x": -737.1515702145864,
      "y": 573.3401101669006,
      "type": "shipyard"
    },
    {
      "x": -352.19463910252466,
      "y": 720.7704242098179,
      "type": "shipyard"
    },
    {
      "x": 188.38317905483876,
      "y": 704.3892782050493,
      "type": "shipyard"
    },
    {
      "x": 597.9118291740534,
      "y": 655.2458401907435,
      "type": "shipyard"
    },
    {
      "x": 1228.5859503576442,
      "y": 540.5778181573634,
      "type": "shipyard"
    },
    {
      "x": -1425.159702414867,
      "y": 1646.305173479243,
      "type": "refinery"
    },
    {
      "x": -876.3913112551195,
      "y": 1793.7354875221604,
      "type": "refinery"
    },
    {
      "x": -319.43234709298747,
      "y": 1859.2600715412348,
      "type": "refinery"
    },
    {
      "x": 303.0512010882189,
      "y": 1867.450644543619,
      "type": "refinery"
    },
    {
      "x": 860.0101652503508,
      "y": 1900.2129365531562,
      "type": "refinery"
    },
    {
      "x": -1449.73142142202,
      "y": 2137.7395536223007,
      "type": "fueling"
    },
    {
      "x": -884.5818842575037,
      "y": 2186.8829916366067,
      "type": "fueling"
    },
    {
      "x": -499.6249531454419,
      "y": 2244.2170026532967,
      "type": "fueling"
    },
    {
      "x": 98.28687602861153,
      "y": 2268.7887216604495,
      "type": "fueling"
    },
    {
      "x": 671.6269861955121,
      "y": 2285.169867665218,
      "type": "fueling"
    },
    {
      "x": -1900.2129365531562,
      "y": -1433.3502754172514,
      "type": "warpgate"
    },
    {
      "x": -1498.8748594363258,
      "y": -1842.878925536466,
      "type": "warpgate"
    },
    {
      "x": -941.9158952741938,
      "y": -2104.9772616127634,
      "type": "warpgate"
    },
    {
      "x": -196.57375205722306,
      "y": -2203.264137641375,
      "type": "warpgate"
    },
    {
      "x": 360.38521210490893,
      "y": -2203.264137641375,
      "type": "warpgate"
    },
    {
      "x": 1310.491680381487,
      "y": -2162.3112726294535,
      "type": "piratebase"
    },
    {
      "x": 2104.9772616127634,
      "y": -1679.0674654887803,
      "type": "piratebase"
    },
    {
      "x": 993.4741168946478,
      "y": -1001.0004359620316,
      "type": "shop"
    },
    {
      "x": 940,
      "y": -966.6666666666667,
      "type": "warpgate"
    },
    {
      "x": 500,
      "y": -913.3333333333334,
      "type": "warpgate"
    }
  ]
}
```

## c:\Users\jsamu\.cursor\plans\unified_dom_hotbar_refactor_94b4aa43.plan.md
```
---
name: Unified DOM Hotbar Refactor
overview: Refactor the game's hotbar and item rendering to use a single, unified DOM-based system for both the in-game HUD and the Shop UI. This will eliminate visual inconsistencies and simplify the codebase by removing duplicate Canvas rendering logic.
todos: []
isProject: false
---

# Unified DOM Hotbar Refactor Plan

## 1. HTML Restructuring
- Move `#shop-hotbar-overlay` (containing `#shop-hotbar` and `#shop-credits`) out of `#shop-menu-overlay` to become a top-level `#hud-overlay`.
- Rename IDs for clarity:
    - `#shop-hotbar-overlay` -> `#hud-overlay`
    - `#shop-hotbar` -> `#hotbar`
    - `#shop-credits` -> `#credits`
- Update the generic `.shop-slot` class to `.slot` or keep `.shop-slot` but ensure it applies globally.
- Ensure `#hud-overlay` is positioned correctly (bottom center) and visible during both gameplay and shop mode.

## 2. CSS Updates
- Update styles to match the new IDs (`#hotbar`, `#credits`).
- Ensure `#hud-overlay` has `z-index` higher than the game canvas and appropriate `pointer-events` settings (container `none`, slots `auto`) to allow clicking through to the game but interacting with the UI.
- Add `cursor: pointer` to hotbar slots in CSS (handling the "hand cursor" requirement natively).

## 3. JavaScript Visual Refactor (`js/game.js`)
- **Shared HTML Generator:** Create `getSlotHTML(item)` helper function that returns the inner HTML string for any item slot (icon, quantity, charge bars).
- **HUD Update Function:** Create `updateHUD()` function to:
    - Sync `#hotbar` slots with `hotbar[]` data.
    - Update `#credits` display.
    - Use `getSlotHTML` for rendering items.
- **Refactor Shop Updates:** Update `syncShopBuyArea()` and `syncShopSellArea()` to use `getSlotHTML` for consistency.
- **Remove Canvas Drawing:** Delete all code in `render()` that draws the hotbar, slots, and credits text to the canvas.

## 4. Interaction Refactor (`js/game.js`)
- **Unified Drag System:** Generalize the existing `shopDrag` (ghost element) system to work globally as `inventoryDrag`.
    - Attach `mousedown` listeners to `#hotbar` slots to handle selection (left click) and dragging.
    - Handle `mouseup` globally to support dropping items.
- **Remove Canvas Interaction:** Remove the canvas-based `mousedown`/`mousemove` logic that detected hotbar clicks (since DOM now handles this).
- **Game Loop Integration:** Call `updateHUD()` in the game loop (or only when inventory changes) to keep the display in sync.

## 5. Cleanup
- Remove unused variables/constants related to Canvas hotbar dimensions (`slotSize`, `hotbarWidth` in drawing code).
- Verify crosshair rendering is not affected (except it won't draw *over* the DOM hotbar, which is correct).

## Files to Modify
- `index.html`: Structure changes.
- `css/style.css`: Styling for new HUD ID and positioning.
- `js/game.js`: Render logic refactor and interaction updates.
```

## c:\Users\jsamu\Cursor projects\AI Generated Space Jam\index.html
```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Game</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas" tabindex="1"></canvas>
    <div id="warp-menu-overlay" style="display: none;">
      <div id="warp-menu">
        <p>Use warp gate?</p>
        <p>Cost: 100 credits</p>
        <button type="button" id="warp-pay-btn">Pay 100</button>
        <button type="button" id="warp-cancel-btn">Cancel</button>
      </div>
    </div>
    <div id="shop-menu-overlay" style="display: none;">
      <div id="shop-menu">
        <div id="shop-header">
          <span>Shop</span>
          <button type="button" id="shop-close-btn">Close</button>
        </div>
        <div id="shop-main">
          <div id="shop-buy-area">
            <div class="shop-section-title">Buy</div>
            <div id="shop-buy-slots">
              <div class="shop-buy-slot" data-buy-slot="0"></div>
              <div class="shop-buy-slot" data-buy-slot="1"></div>
              <div class="shop-buy-slot" data-buy-slot="2"></div>
              <div class="shop-buy-slot" data-buy-slot="3"></div>
              <div class="shop-buy-slot" data-buy-slot="4"></div>
              <div class="shop-buy-slot" data-buy-slot="5"></div>
              <div class="shop-buy-slot" data-buy-slot="6"></div>
              <div class="shop-buy-slot" data-buy-slot="7"></div>
              <div class="shop-buy-slot" data-buy-slot="8"></div>
            </div>
            <div id="shop-price-list"></div>
          </div>
          <div id="shop-sell-area">
            <div class="shop-section-title">Sell</div>
            <div id="shop-sell-slots">
              <div class="shop-sell-slot" data-sell-slot="0"></div>
              <div class="shop-sell-slot" data-sell-slot="1"></div>
              <div class="shop-sell-slot" data-sell-slot="2"></div>
              <div class="shop-sell-slot" data-sell-slot="3"></div>
              <div class="shop-sell-slot" data-sell-slot="4"></div>
              <div class="shop-sell-slot" data-sell-slot="5"></div>
              <div class="shop-sell-slot" data-sell-slot="6"></div>
              <div class="shop-sell-slot" data-sell-slot="7"></div>
              <div class="shop-sell-slot" data-sell-slot="8"></div>
            </div>
            <div id="shop-sell-total">Total: 0 credits</div>
            <button type="button" id="shop-sell-btn">Sell</button>
          </div>
        </div>
      </div>
    </div>
    <div id="shop-drag-ghost" style="display: none;" aria-hidden="true"></div>
    <div id="fuel-bar-drop-zone" aria-label="Fuel bar - drop fuel can to refill"></div>
    <div id="hud-overlay" aria-label="Hotbar">
      <div id="hotbar">
        <div class="slot" data-slot="0"></div>
        <div class="slot" data-slot="1"></div>
        <div class="slot" data-slot="2"></div>
        <div class="slot" data-slot="3"></div>
        <div class="slot" data-slot="4"></div>
        <div class="slot" data-slot="5"></div>
        <div class="slot" data-slot="6"></div>
        <div class="slot" data-slot="7"></div>
        <div class="slot" data-slot="8"></div>
      </div>
      <div id="credits">
        <div class="credits-label">Credits</div>
        <div class="credits-value">0</div>
      </div>
    </div>
    <div id="game-ui">
      <a href="editor.html">Level Editor</a>
      <label>Level: <select id="level-select"></select></label>
      <span>Press L to load a level</span>
    </div>
  </div>
  <script src="js/game.js"></script>
</body>
</html>

```

## c:\Users\jsamu\Cursor projects\AI Generated Space Jam\css\style.css
```
* {
  margin: 0;
  padding: 0;
}

body {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background: #1a1a1a;
}

#game-container {
  position: relative;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
}

#game-canvas {
  display: block;
  background: #111;
  /* Fixed pixel size - prevents 4K from scaling canvas and tanking performance */
  width: 1200px;
  height: 900px;
  cursor: none;
}

#game-ui {
  position: absolute;
  top: 10px;
  left: 10px;
  display: flex;
  gap: 15px;
  font-family: Arial, sans-serif;
  font-size: 12px;
}

#game-ui a {
  color: #6af;
  text-decoration: none;
}

#game-ui a:hover {
  text-decoration: underline;
}

#game-ui span {
  color: #666;
}

#game-ui label {
  color: #ccc;
  display: flex;
  align-items: center;
  gap: 6px;
}

#game-ui select {
  background: #333;
  color: #fff;
  border: 1px solid #555;
  padding: 2px 6px;
  font-size: 12px;
}

#warp-menu-overlay {
  position: absolute;
  left: 0;
  top: 0;
  width: 1200px;
  height: 900px;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
}

#warp-menu {
  background: #2a2a2a;
  padding: 24px;
  border-radius: 8px;
  min-width: 200px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  border: 1px solid #555;
}

#warp-menu p {
  margin: 0;
  color: #eee;
  font-family: Arial, sans-serif;
  font-size: 14px;
}

#warp-menu button {
  padding: 8px 16px;
  margin: 0 4px;
  font-size: 14px;
  cursor: pointer;
  border: 1px solid #666;
  border-radius: 4px;
  background: #444;
  color: #fff;
}

#warp-menu button:hover:not(:disabled) {
  background: #555;
}

#warp-menu button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

#shop-menu-overlay {
  position: absolute;
  left: 0;
  top: 0;
  width: 1200px;
  height: 900px;
  background: rgba(0, 0, 0, 0.35);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  z-index: 10;
  pointer-events: auto;
  cursor: default;
}

#shop-menu {
  background: rgba(30, 30, 30, 0.95);
  padding: 20px;
  border-radius: 8px;
  min-width: 320px;
  display: flex;
  flex-direction: column;
  gap: 16px;
  border: 1px solid #666;
  pointer-events: auto;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
}

#shop-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

#shop-header span {
  color: #eee;
  font-family: Arial, sans-serif;
  font-size: 18px;
}

#shop-main {
  display: flex;
  flex-direction: row;
  gap: 24px;
  align-items: flex-start;
}

#shop-buy-area,
#shop-sell-area {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.shop-section-title {
  color: #bbb;
  font-family: Arial, sans-serif;
  font-size: 12px;
  text-transform: uppercase;
}

#shop-buy-slots,
#shop-sell-slots {
  display: grid;
  grid-template-columns: repeat(3, 40px);
  gap: 0;
}

.shop-buy-slot {
  width: 40px;
  height: 40px;
  box-sizing: border-box;
  border: 1px solid #555;
  background: #222;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #fff;
  font-family: Arial, sans-serif;
  font-size: 12px;
  position: relative;
  user-select: none;
  overflow: hidden;
}

.shop-buy-slot.has-item {
  cursor: grab;
}

.shop-buy-slot.has-item:active {
  cursor: grabbing;
}

#shop-price-list {
  margin-top: 8px;
  font-family: Arial, sans-serif;
  font-size: 11px;
  color: #ccc;
}

#shop-price-list .price-row {
  display: flex;
  justify-content: space-between;
  padding: 2px 0;
}

#shop-price-list .price-label {
  color: #aaa;
}

#shop-price-list .price-value {
  color: #9c9;
}

/* Generic slot child elements */
.slot-icon {
  margin-top: -4px;
}

.slot-energy {
  position: absolute;
  bottom: 6px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 9px;
  color: #aaffaa;
}

.slot-bar {
  position: absolute;
  right: 3px;
  top: 3px;
  width: 5px;
  height: 32px;
  background: #333;
}

.slot-bar-fill {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
}

.slot-qty {
  position: absolute;
  bottom: 2px;
  right: 2px;
  font-size: 10px;
  color: #aaa;
}

.slot-num {
  position: absolute;
  top: 2px;
  left: 2px;
  font-size: 10px;
  color: #666;
}

/* Main Hotbar Slots */
.slot {
  width: 40px;
  height: 40px;
  box-sizing: border-box;
  border: 1px solid #555;
  background: #222;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #fff;
  font-family: Arial, sans-serif;
  font-size: 12px;
  position: relative;
  user-select: none;
  overflow: hidden;
  cursor: pointer;
}

.slot.selected {
  border: 2px solid #fff;
  background: #444;
}

.slot.has-item {
  cursor: grab;
}

.slot.has-item:active {
  cursor: grabbing;
}

/* Sell Slots */
.shop-sell-slot {
  width: 40px;
  height: 40px;
  box-sizing: border-box;
  border: 1px solid #555;
  background: #222;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #fff;
  font-family: Arial, sans-serif;
  font-size: 12px;
  position: relative;
  user-select: none;
  overflow: hidden;
}

.shop-sell-slot.has-item {
  cursor: grab;
}

.shop-sell-slot.has-item:active {
  cursor: grabbing;
}

.shop-sell-slot.droppable {
  border-color: #6a6;
  background: #2a3a2a;
}

#shop-sell-total {
  color: #9c9;
  font-family: Arial, sans-serif;
  font-size: 14px;
  margin-top: 4px;
}

#shop-menu button {
  padding: 8px 16px;
  margin: 0 4px;
  font-size: 14px;
  cursor: pointer;
  border: 1px solid #666;
  border-radius: 4px;
  background: #444;
  color: #fff;
}

#shop-menu button:hover:not(:disabled) {
  background: #555;
}

#shop-menu button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

#fuel-bar-drop-zone {
  position: absolute;
  left: 1100px;
  bottom: 20px;
  width: 40px;
  height: 50px;
  pointer-events: auto;
  z-index: 15;
  box-sizing: border-box;
  border: 2px solid transparent;
  transition: border-color 0.15s;
}

#fuel-bar-drop-zone.highlight {
  border-color: #fff;
}

#hud-overlay {
  position: absolute;
  /* Hotbar is 360px wide, centered in 1200px = starts at 420px */
  left: 420px;
  bottom: 0;
  pointer-events: auto;
  display: flex;
  flex-direction: row;
  z-index: 15;
}

#hotbar {
  display: flex;
  flex-direction: row;
  gap: 0;
}

#credits {
  width: 80px;
  height: 40px;
  background: #222;
  border: 1px solid #555;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
}

.credits-label {
  color: #ffcc00;
  font-family: Arial, sans-serif;
  font-size: 12px;
}

.credits-value {
  color: #fff;
  font-family: Arial, sans-serif;
  font-size: 14px;
}

#shop-drag-ghost {
  position: fixed;
  width: 40px;
  height: 40px;
  background: rgba(40, 40, 40, 0.8);
  border: 2px solid #aaa;
  color: #fff;
  font-family: Arial, sans-serif;
  font-size: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  z-index: 9999;
}

```

## c:\Users\jsamu\Cursor projects\AI Generated Space Jam\js\game.js
```
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');

const WIDTH = 1200;
const HEIGHT = 900;

const ACCEL = 150;
const FRICTION = 0.15;
const MAX_SPEED = 175;
const BRAKE_FRICTION = 1.5;
const BULLET_SPEED = 1000;
const FIRE_COOLDOWN = 0.03;

canvas.width = WIDTH;
canvas.height = HEIGHT;

// Seeded RNG for reproducible starfield per level (mulberry32)
function createSeededRandom(seed) {
  return function () {
    let t = (seed += 0x6d2b79f5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

// Ship (world coordinates, camera follows)
const ship = {
  x: 0,
  y: 0,
  vx: 0,
  vy: 0
};

// Player stats
const player = {
  health: 50.0,
  maxHealth: 50.0,
  fuel: 25.0,
  maxFuel: 25.0,
  oxygen: 30.0,
  maxOxygen: 30.0,
  credits: 0
};
const OXYGEN_DEPLETION_RATE = 1 / 10; // 1 per 10 seconds

// Inventory hotbar (9 slots, each can hold { item, quantity?, energy?, maxEnergy? } or null)
const hotbar = [
  { item: 'mining laser', heat: 0, overheated: false }, // heat 0-1, overheated locks until cooled to 0
  { item: 'energy cell', energy: 10, maxEnergy: 10 },
  { item: 'energy cell', energy: 10, maxEnergy: 10 },
  null, null, null, null, null, null
];
const LASER_HEAT_RATE = 1;    // per second when firing (full in 1 sec)
const LASER_COOL_RATE = 1 / 3; // per second when not firing (empty in 3 sec)
let selectedSlot = 0;

function getFirstChargedCell() {
  for (let i = 0; i < hotbar.length; i++) {
    const cell = hotbar[i];
    if (cell && cell.item === 'energy cell' && cell.energy != null && cell.energy > 0) return cell;
  }
  return null;
}

const WEAPON_ENERGY_DRAIN = 1; // per second when firing

// Mouse state
let mouseX = WIDTH / 2;
let mouseY = HEIGHT / 2;
let rightMouseDown = false;
let leftMouseDown = false;
let ctrlBrake = false;

let gamePaused = false;
let warpMenuOpen = false;
let shopMenuOpen = false;

// Bullets
const bullets = [];
let fireCooldown = 0;

// Asteroids (loaded from level)
let asteroids = [];
let structures = [];
let levelWidth = 10000;
let levelHeight = 10000;

// Floating items in space (dropped/jettisoned)
const floatingItems = [];

// Spark particles for laser impact
const particles = [];
let sparkCarry = 0; // fractional sparks accumulator (FPS independent)

function spawnSparks(x, y, count) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 50 + Math.random() * 150;
    const life = 0.2 + Math.random() * 0.3; // 0.2-0.5 seconds
    particles.push({
      x: x,
      y: y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life,
      maxLife: life,
      size: 1 + Math.random() * 2
    });
  }
}

// Drag state for hotbar (Legacy canvas drag removed)


const MAX_ORE_STACK = 5;
const ORE_ITEMS = ['cuprite']; // items that stack up to MAX_ORE_STACK

function getMaxStack(itemName) {
  return ORE_ITEMS.includes(itemName) ? MAX_ORE_STACK : 1;
}

// Add item to inventory (find matching stack or first empty slot)
function addToInventory(itemName, quantity) {
  const maxStack = getMaxStack(itemName);

  while (quantity > 0) {
    // First try to stack with existing item (up to maxStack)
    let added = false;
    for (let i = 0; i < hotbar.length && quantity > 0; i++) {
      if (hotbar[i] && hotbar[i].item === itemName && hotbar[i].quantity != null && hotbar[i].quantity < maxStack) {
        const space = maxStack - hotbar[i].quantity;
        const add = Math.min(quantity, space);
        hotbar[i].quantity += add;
        quantity -= add;
        added = true;
      }
    }
    if (quantity <= 0) return true;
    // Otherwise find first empty slot
    for (let i = 0; i < hotbar.length; i++) {
      if (!hotbar[i]) {
        const add = Math.min(quantity, maxStack);
        hotbar[i] = { item: itemName, quantity: add };
        quantity -= add;
        added = true;
        break;
      }
    }
    if (!added) return false; // Inventory full, quantity left is lost
  }
  return true;
}

// Starfield
const NUM_STARS = 2400;
const stars = [];

function initStars() {
  const spread = 5000;
  for (let i = 0; i < NUM_STARS; i++) {
    stars.push({
      x: (Math.random() - 0.5) * 2 * spread,
      y: (Math.random() - 0.5) * 2 * spread,
      size: Math.random() * 2 + 0.5,
      brightness: 0.3 + Math.random() * 0.7
    });
  }
}

function normalize(x, y) {
  const len = Math.sqrt(x * x + y * y);
  if (len === 0) return { x: 0, y: 0 };
  return { x: x / len, y: y / len };
}

function worldToScreen(wx, wy) {
  return {
    x: wx - ship.x + WIDTH / 2,
    y: wy - ship.y + HEIGHT / 2
  };
}

// Laser raycast: find closest asteroid hit by a ray from (ox, oy) in direction (dx, dy)
function laserHitAsteroid(ox, oy, dx, dy, maxLen) {
  let closest = null;
  let closestDist = maxLen;
  
  for (const ast of asteroids) {
    // Vector from ray origin to asteroid center
    const fx = ast.x - ox;
    const fy = ast.y - oy;
    
    // Project asteroid center onto ray
    const t = fx * dx + fy * dy;
    if (t < 0) continue; // Behind ray origin
    
    // Closest point on ray to asteroid center
    const cx = ox + dx * t;
    const cy = oy + dy * t;
    
    // Distance from closest point to asteroid center
    const distSq = (ast.x - cx) * (ast.x - cx) + (ast.y - cy) * (ast.y - cy);
    const radiusSq = ast.radius * ast.radius;
    
    if (distSq < radiusSq) {
      // Ray hits asteroid - calculate entry distance
      const offset = Math.sqrt(radiusSq - distSq);
      const hitDist = t - offset;
      
      if (hitDist > 0 && hitDist < closestDist) {
        closest = ast;
        closestDist = hitDist;
      }
    }
  }
  
  return closest ? { asteroid: closest, distance: closestDist } : null;
}

const SHIP_SIZE = 10;
const SHIP_COLLISION_RADIUS = 8;
const SHIP_COLLECTION_RADIUS = 16;

const SHOT_SPREAD = 8;

function fireBullet() {
  const dx = mouseX - WIDTH / 2;
  const dy = mouseY - HEIGHT / 2;
  const dir = normalize(dx, dy);
  if (dir.x === 0 && dir.y === 0) return;
  const perp = { x: -dir.y, y: dir.x };
  const offsets = [-SHOT_SPREAD, 0, SHOT_SPREAD];
  for (const offset of offsets) {
    bullets.push({
      x: ship.x + dir.x * SHIP_SIZE + perp.x * offset,
      y: ship.y + dir.y * SHIP_SIZE + perp.y * offset,
      vx: dir.x * BULLET_SPEED + ship.vx,
      vy: dir.y * BULLET_SPEED + ship.vy,
      lifespan: 2
    });
  }
}

function drawShip() {
  const cx = WIDTH / 2;
  const cy = HEIGHT / 2;
  const dx = mouseX - cx;
  const dy = mouseY - cy;
  const dir = normalize(dx, dy);
  const angle = Math.atan2(dir.y, dir.x);

  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(angle);
  ctx.fillStyle = '#fff';
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(SHIP_SIZE, 0);
  ctx.lineTo(-SHIP_SIZE * 0.7, SHIP_SIZE * 0.6);
  ctx.lineTo(-SHIP_SIZE * 0.4, 0);
  ctx.lineTo(-SHIP_SIZE * 0.7, -SHIP_SIZE * 0.6);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  ctx.restore();

  if (!shopMenuOpen) {
    // Custom crosshair: vertical arms 2px wide (filled rects), horizontal arms 1px strokes
    const armLen = 6;
    const centerGap = 2;
    const crosshairX = Math.floor(mouseX) + 0.5;
    const crosshairY = Math.floor(mouseY) + 0.5;
    const armW = 2;
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    // Top stick (2px wide)
    ctx.fillRect(crosshairX - armW / 2, crosshairY - armLen, armW, armLen - centerGap);
    // Bottom stick (2px wide)
    ctx.fillRect(crosshairX - armW / 2, crosshairY + centerGap, armW, armLen - centerGap);
    // Left/right arms (1px strokes, pixel-aligned)
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.lineWidth = 1;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(crosshairX - armLen, crosshairY);
    ctx.lineTo(crosshairX - centerGap, crosshairY);
    ctx.moveTo(crosshairX + centerGap, crosshairY);
    ctx.lineTo(crosshairX + armLen, crosshairY);
    ctx.stroke();

    // Heat bar under crosshair for currently equipped weapon (mining laser)
    const equipped = hotbar[selectedSlot];
    if (equipped && equipped.item === 'mining laser' && equipped.heat != null && equipped.heat > 0) {
      const barW = 16;
      const barH = 4;
      const barY = mouseY + 8;
      const barX = mouseX - barW / 2;
      const isOverheated = equipped.overheated;
      ctx.fillStyle = isOverheated ? 'rgba(255, 0, 0, 0.2)' : 'rgba(255, 255, 255, 0.2)';
      ctx.fillRect(barX, barY, barW, barH);
      ctx.fillStyle = isOverheated ? 'rgba(255, 0, 0, 0.6)' : 'rgba(255, 255, 255, 0.6)';
      ctx.fillRect(barX, barY, barW * Math.min(1, equipped.heat), barH);
    }
  }
}

function update(dt) {
  // Ship movement (right-click) - only if there's a direction to move
  if (rightMouseDown && player.fuel > 0) {
    const dx = mouseX - WIDTH / 2;
    const dy = mouseY - HEIGHT / 2;
    const dir = normalize(dx, dy);
    // Only apply thrust and consume fuel if there's a direction
    if (dir.x !== 0 || dir.y !== 0) {
      ship.vx += dir.x * ACCEL * dt;
      ship.vy += dir.y * ACCEL * dt;
      player.fuel = Math.max(0, player.fuel - 1 * dt);
    }
  }

  // Friction (low when coasting, high when braking with Ctrl)
  const friction = ctrlBrake ? BRAKE_FRICTION : FRICTION;
  ship.vx *= Math.max(0, 1 - friction * dt);
  ship.vy *= Math.max(0, 1 - friction * dt);

  // Max speed cap
  const speed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
  if (speed > MAX_SPEED) {
    const scale = MAX_SPEED / speed;
    ship.vx *= scale;
    ship.vy *= scale;
  }

  // Position
  ship.x += ship.vx * dt;
  ship.y += ship.vy * dt;

  // Shipâ€“asteroid collision: bounce and damage from perpendicular impact speed
  const BOUNCE_RESTITUTION = 0.3;
  const MAX_COLLISION_DAMAGE = 20;
  const DAMAGE_PER_SPEED = 0.1; // 200 units/sec impact => 20 damage
  for (const ast of asteroids) {
    const dx = ship.x - ast.x;
    const dy = ship.y - ast.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const minDist = SHIP_COLLISION_RADIUS + ast.radius;
    if (dist < minDist && dist > 0) {
      const nx = dx / dist;
      const ny = dy / dist;
      // Push ship out of overlap
      const overlap = minDist - dist;
      ship.x += nx * overlap;
      ship.y += ny * overlap;
      // Perpendicular impact speed (into asteroid is negative)
      const normalSpeed = ship.vx * nx + ship.vy * ny;
      if (normalSpeed < 0) {
        // Ship is moving into asteroid
        const impactSpeed = -normalSpeed; // positive value
        // Bounce: cancel inward velocity and add small outward push
        const bounce = impactSpeed * (1 + BOUNCE_RESTITUTION);
        ship.vx += nx * bounce;
        ship.vy += ny * bounce;
        // Damage from impact speed, max 20
        const damage = Math.min(MAX_COLLISION_DAMAGE, impactSpeed * DAMAGE_PER_SPEED);
        player.health = Math.max(0, player.health - damage);
      }
    }
  }

  // Shipâ€“warp gate and shop collision (same logic as asteroids, radius 40)
  const STRUCTURE_SIZE_COLL = 40;
  for (const st of structures) {
    if (st.type !== 'warpgate' && st.type !== 'shop') continue;
    const dx = ship.x - st.x;
    const dy = ship.y - st.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const minDist = SHIP_COLLISION_RADIUS + STRUCTURE_SIZE_COLL;
    if (dist < minDist && dist > 0) {
      const nx = dx / dist;
      const ny = dy / dist;
      const overlap = minDist - dist;
      ship.x += nx * overlap;
      ship.y += ny * overlap;
      const normalSpeed = ship.vx * nx + ship.vy * ny;
      if (normalSpeed < 0) {
        const impactSpeed = -normalSpeed;
        const bounce = impactSpeed * (1 + BOUNCE_RESTITUTION);
        ship.vx += nx * bounce;
        ship.vy += ny * bounce;
        const damage = Math.min(MAX_COLLISION_DAMAGE, impactSpeed * DAMAGE_PER_SPEED);
        player.health = Math.max(0, player.health - damage);
      }
    }
  }

  // Oxygen depletion
  player.oxygen = Math.max(0, player.oxygen - OXYGEN_DEPLETION_RATE * dt);
  
  // No oxygen: drain health at 1 per second
  if (player.oxygen <= 0) {
    player.health = Math.max(0, player.health - 1 * dt);
  }

  // Fire only when mining laser is selected; drain energy; heat blocks fire when full
  const hasEnergy = getFirstChargedCell() != null;
  const miningLaser = hotbar[selectedSlot] && hotbar[selectedSlot].item === 'mining laser' ? hotbar[selectedSlot] : null;
  const miningLaserSelected = miningLaser != null;

  if (miningLaser && miningLaser.heat != null) {
    // Set overheated when heat reaches 1
    if (miningLaser.heat >= 1) {
      miningLaser.overheated = true;
    }
    // Clear overheated only when fully cooled
    if (miningLaser.heat <= 0) {
      miningLaser.overheated = false;
    }

    const canFire = !miningLaser.overheated;
    if (miningLaserSelected && leftMouseDown && hasEnergy && canFire) {
      miningLaser.heat = Math.min(1, miningLaser.heat + LASER_HEAT_RATE * dt);
      const cell = getFirstChargedCell();
      if (cell) cell.energy = Math.max(0, cell.energy - WEAPON_ENERGY_DRAIN * dt);
      
      // Laser damage to asteroids: 5 DPS
      const dx = mouseX - WIDTH / 2;
      const dy = mouseY - HEIGHT / 2;
      const dir = normalize(dx, dy);
      if (dir.x !== 0 || dir.y !== 0) {
        const hit = laserHitAsteroid(ship.x, ship.y, dir.x, dir.y, 1500);
        if (hit) {
          hit.asteroid.health -= 5 * dt;
          // Spawn sparks at impact point
          const hitX = ship.x + dir.x * hit.distance;
          const hitY = ship.y + dir.y * hit.distance;
          // ~60 sparks per second, frame-rate independent
          sparkCarry += 60 * dt;
          const n = Math.floor(sparkCarry);
          if (n > 0) {
            spawnSparks(hitX, hitY, n);
            sparkCarry -= n;
          }
        }
      }
    } else {
      miningLaser.heat = Math.max(0, miningLaser.heat - LASER_COOL_RATE * dt);
    }
  }

  // Bullets
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    b.lifespan -= dt;
    if (b.lifespan <= 0) bullets.splice(i, 1);
  }

  // Particles (sparks)
  const PARTICLE_DRAG = 6; // per-second velocity decay
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    const damp = Math.exp(-PARTICLE_DRAG * dt);
    p.vx *= damp;
    p.vy *= damp;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Check for destroyed asteroids and drop ore
  for (let i = asteroids.length - 1; i >= 0; i--) {
    if (asteroids[i].health <= 0) {
      const ast = asteroids[i];
      const oreCount = Math.floor(ast.radius / 10);
      if (oreCount > 0) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 30 + Math.random() * 50;
        floatingItems.push({
          x: ast.x,
          y: ast.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          item: 'cuprite',
          quantity: oreCount
        });
      }
      asteroids.splice(i, 1);
    }
  }

  // Floating items: magnet + movement + drag
  const MAGNET_RADIUS = 80;
  const MAGNET_STRENGTH = 600; // acceleration (units/sec^2) near ship
  const FLOAT_DRAG = 2.0; // velocity damping per second
  const FLOAT_STOP_SPEED = 0.05;
  for (const item of floatingItems) {
    if (item.vx == null) item.vx = 0;
    if (item.vy == null) item.vy = 0;

    // Magnet attraction (accumulates smoothly; no "speed < 1 => zero" bug)
    const dx = ship.x - item.x;
    const dy = ship.y - item.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist > 0 && dist < MAGNET_RADIUS && dist > SHIP_COLLISION_RADIUS) {
      const inv = 1 / dist;
      const pull = MAGNET_STRENGTH * (1 - dist / MAGNET_RADIUS);
      item.vx += dx * inv * pull * dt;
      item.vy += dy * inv * pull * dt;
    }

    // Integrate movement
    item.x += item.vx * dt;
    item.y += item.vy * dt;

    // Collision with asteroids and warp gates: push out so items don't overlap
    const FLOAT_ITEM_RADIUS = 10;
    const STRUCTURE_SIZE_COLL = 40;
    for (const ast of asteroids) {
      const dx = item.x - ast.x;
      const dy = item.y - ast.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const minDist = ast.radius + FLOAT_ITEM_RADIUS;
      if (dist < minDist && dist > 0) {
        const nx = dx / dist;
        const ny = dy / dist;
        const overlap = minDist - dist;
        item.x += nx * overlap;
        item.y += ny * overlap;
      }
    }
    for (const st of structures) {
      if (st.type !== 'warpgate' && st.type !== 'shop') continue;
      const dx = item.x - st.x;
      const dy = item.y - st.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const minDist = STRUCTURE_SIZE_COLL + FLOAT_ITEM_RADIUS;
      if (dist < minDist && dist > 0) {
        const nx = dx / dist;
        const ny = dy / dist;
        const overlap = minDist - dist;
        item.x += nx * overlap;
        item.y += ny * overlap;
      }
    }

    // Apply drag (exponential decay)
    const damp = Math.max(0, 1 - FLOAT_DRAG * dt);
    item.vx *= damp;
    item.vy *= damp;

    // Stop tiny drift
    const sp = Math.sqrt(item.vx * item.vx + item.vy * item.vy);
    if (sp < FLOAT_STOP_SPEED) {
      item.vx = 0;
      item.vy = 0;
    }
  }

  // Pickup floating items only when within ship collision radius
  for (let i = floatingItems.length - 1; i >= 0; i--) {
    const item = floatingItems[i];
    const dx = item.x - ship.x;
    const dy = item.y - ship.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < SHIP_COLLECTION_RADIUS) {
      // Energy cells restore their charge - find empty slot
      if (item.energy != null) {
        let added = false;
        for (let j = 0; j < hotbar.length; j++) {
          if (!hotbar[j]) {
            hotbar[j] = { item: item.item, energy: item.energy, maxEnergy: item.maxEnergy };
            added = true;
            break;
          }
        }
        if (added) floatingItems.splice(i, 1);
      } else if (item.fuel != null) {
        let added = false;
        for (let j = 0; j < hotbar.length; j++) {
          if (!hotbar[j]) {
            hotbar[j] = { item: item.item, fuel: item.fuel, maxFuel: item.maxFuel };
            added = true;
            break;
          }
        }
        if (added) floatingItems.splice(i, 1);
      } else if (item.item === 'mining laser' && item.heat != null) {
        // Mining laser: restore heat/overheated
        let added = false;
        for (let j = 0; j < hotbar.length; j++) {
          if (!hotbar[j]) {
            hotbar[j] = { item: item.item, heat: item.heat, overheated: !!item.overheated };
            added = true;
            break;
          }
        }
        if (added) floatingItems.splice(i, 1);
      } else if (addToInventory(item.item, item.quantity)) {
        floatingItems.splice(i, 1);
      }
    }
  }
}

function render() {
  ctx.fillStyle = '#0a0a12';
  ctx.fillRect(0, 0, WIDTH, HEIGHT);

  // Starfield (fillRect is much faster than arc for small shapes)
  for (const star of stars) {
    const sx = star.x - ship.x + WIDTH / 2;
    const sy = star.y - ship.y + HEIGHT / 2;
    if (sx < -10 || sx > WIDTH + 10 || sy < -10 || sy > HEIGHT + 10) continue;
    const s = Math.max(1, star.size);
    ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
    ctx.fillRect(sx - s / 2, sy - s / 2, s, s);
  }

  // Asteroids
  for (const ast of asteroids) {
    const { x, y } = worldToScreen(ast.x, ast.y);
    const r = ast.radius;
    if (x + r < 0 || x - r > WIDTH || y + r < 0 || y - r > HEIGHT) continue;
    ctx.fillStyle = '#665544';
    ctx.strokeStyle = '#998877';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
  }

  // Floating items in space
  for (const item of floatingItems) {
    const { x, y } = worldToScreen(item.x, item.y);
    if (x < -20 || x > WIDTH + 20 || y < -20 || y > HEIGHT + 20) continue;
    const icon = item.item === 'cuprite' ? 'C' : (item.item === 'energy cell' ? 'E' : (item.item === 'fuel can' ? 'F' : (item.item === 'mining laser' ? 'L' : item.item.charAt(0).toUpperCase())));
    // Draw small glowing circle - energy cells green, fuel cans orange, mining laser orange, ore default
    ctx.fillStyle = item.energy != null ? '#448844' : (item.fuel != null ? '#886622' : (item.heat != null ? '#884422' : '#aa8844'));
    ctx.beginPath();
    ctx.arc(x, y, 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = item.energy != null ? '#66cc66' : (item.fuel != null ? '#cc8844' : (item.heat != null ? '#cc6633' : '#ccaa66'));
    ctx.lineWidth = 2;
    ctx.stroke();
    // Item icon
    ctx.fillStyle = '#fff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(icon, x, y);
    // Quantity if > 1
    if (item.quantity > 1) {
      ctx.fillStyle = '#ffcc00';
      ctx.font = '8px Arial';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'bottom';
      ctx.fillText(item.quantity, x + 12, y + 12);
    }
  }

  // Structures (render as circles)
  const STRUCTURE_SIZE = 40;
  const WARP_GATE_DASHED_EXTRA = 80;
  const SHOP_DASHED_EXTRA = 80;
  const STRUCTURE_STYLES = { shop: '#446688', shipyard: '#664466', refinery: '#666644', fueling: '#446644', warpgate: '#6644aa', piratebase: '#884422' };
  for (const st of structures) {
    const { x, y } = worldToScreen(st.x, st.y);
    const r = STRUCTURE_SIZE;
    const cullR = st.type === 'warpgate' ? STRUCTURE_SIZE + WARP_GATE_DASHED_EXTRA : (st.type === 'shop' ? STRUCTURE_SIZE + SHOP_DASHED_EXTRA : r);
    if (x + cullR < 0 || x - cullR > WIDTH || y + cullR < 0 || y - cullR > HEIGHT) continue;
    ctx.fillStyle = STRUCTURE_STYLES[st.type] || '#446688';
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
    if (st.type === 'warpgate') {
      ctx.stroke();
      const dashedR = STRUCTURE_SIZE + WARP_GATE_DASHED_EXTRA;
      ctx.setLineDash([8, 8]);
      ctx.beginPath();
      ctx.arc(x, y, dashedR, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
    } else if (st.type === 'shop') {
      ctx.stroke();
      const dashedR = STRUCTURE_SIZE + SHOP_DASHED_EXTRA;
      ctx.setLineDash([8, 8]);
      ctx.beginPath();
      ctx.arc(x, y, dashedR, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
    } else {
      ctx.stroke();
    }
    ctx.fillStyle = '#fff';
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const label = st.type === 'warpgate' ? 'W' : (st.type === 'piratebase' ? 'P' : (st.type ? st.type.charAt(0).toUpperCase() : '?'));
    ctx.fillText(label, x, y);
  }

  // Level bounds
  const boundLeft = worldToScreen(-levelWidth / 2, 0).x;
  const boundRight = worldToScreen(levelWidth / 2, 0).x;
  const boundTop = worldToScreen(0, -levelHeight / 2).y;
  const boundBottom = worldToScreen(0, levelHeight / 2).y;
  ctx.strokeStyle = '#335';
  ctx.lineWidth = 2;
  ctx.strokeRect(boundLeft, boundTop, boundRight - boundLeft, boundBottom - boundTop);

  // Bullets (fillRect faster than arc)
  for (const b of bullets) {
    const { x, y } = worldToScreen(b.x, b.y);
    ctx.fillStyle = '#ffcc00';
    ctx.fillRect(x - 2, y - 2, 4, 4);
  }

  // Spark particles
  for (const p of particles) {
    const { x, y } = worldToScreen(p.x, p.y);
    if (x < -10 || x > WIDTH + 10 || y < -10 || y > HEIGHT + 10) continue;
    const alpha = p.life / p.maxLife;
    const r = 255;
    const g = Math.round(150 + 105 * alpha); // yellow to orange
    const b = Math.round(50 * alpha);
    ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
    ctx.fillRect(x - p.size / 2, y - p.size / 2, p.size, p.size);
  }

  // Ship
  drawShip();

  // Mining laser (orange-red line) - only when selected, firing, has energy, and not overheated
  const hasEnergy = getFirstChargedCell() != null;
  const miningLaser = hotbar[selectedSlot] && hotbar[selectedSlot].item === 'mining laser' ? hotbar[selectedSlot] : null;
  const miningLaserSelected = miningLaser != null;
  const canFire = miningLaser && !miningLaser.overheated;
  if (miningLaserSelected && leftMouseDown && hasEnergy && canFire) {
    const cx = WIDTH / 2;
    const cy = HEIGHT / 2;
    const dx = mouseX - cx;
    const dy = mouseY - cy;
    const dir = normalize(dx, dy);
    let laserLength = 1500;
    
    // Check for asteroid hit and shorten laser (stop 10 units before surface)
    if (dir.x !== 0 || dir.y !== 0) {
      const hit = laserHitAsteroid(ship.x, ship.y, dir.x, dir.y, 1500);
      if (hit) {
        laserLength = Math.max(0, hit.distance - 10);
      }
    }
    
    const x1 = cx + dir.x * SHIP_SIZE;
    const y1 = cy + dir.y * SHIP_SIZE;
    const x2 = x1 + dir.x * laserLength;
    const y2 = y1 + dir.y * laserLength;
    // Interpolate color based on heat: orange when cool, deep red when hot
    const heat = miningLaser.heat || 0;
    const outerR = Math.round(255 - heat * 55); // 255 -> 200
    const outerG = Math.round(102 - heat * 102); // 102 -> 0
    const outerB = 0;
    const innerR = Math.round(255 - heat * 55); // 255 -> 200
    const innerG = Math.round(136 - heat * 136); // 136 -> 0
    const innerB = Math.round(68 - heat * 68); // 68 -> 0
    ctx.strokeStyle = `rgb(${outerR},${outerG},${outerB})`;
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.strokeStyle = `rgb(${innerR},${innerG},${innerB})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  // Player stats meters (bottom right) - bar height in pixels = max value in units
  const meterWidth = 40;
  const meterSpacing = 50;
  const meterY = HEIGHT - 20;

  function drawMeter(x, value, max, color, label) {
    const barHeight = max * 2; // 2 pixels per unit
    const fillH = (value / max) * barHeight;
    // Background
    ctx.fillStyle = '#222';
    ctx.fillRect(x - meterWidth / 2, meterY - barHeight, meterWidth, barHeight);
    // Fill
    ctx.fillStyle = color;
    ctx.fillRect(x - meterWidth / 2, meterY - fillH, meterWidth, fillH);
    // Border
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 1;
    ctx.strokeRect(x - meterWidth / 2, meterY - barHeight, meterWidth, barHeight);
    // Label
    ctx.fillStyle = '#aaa';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(label, x, meterY + 4);
    // Value
    ctx.fillStyle = '#fff';
    ctx.textBaseline = 'bottom';
    ctx.fillText(value.toFixed(1), x, meterY - barHeight - 2);
  }

  const rightmost = WIDTH - 30;
  drawMeter(rightmost - 100, player.oxygen, player.maxOxygen, '#44aaff', 'O2');
  drawMeter(rightmost - 50, player.fuel, player.maxFuel, '#ffaa44', 'Fuel');
  drawMeter(rightmost, player.health, player.maxHealth, '#ff4444', 'HP');
}

// Input
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  mouseX = (e.clientX - rect.left) * scaleX;
  mouseY = (e.clientY - rect.top) * scaleY;
});

canvas.addEventListener('mousedown', (e) => {
  if (shopMenuOpen) return;
  if (e.button === 0) {
    leftMouseDown = true;
  } else if (e.button === 2) {
    rightMouseDown = true;
  }
});

canvas.addEventListener('mouseup', (e) => {
  if (shopMenuOpen) return;
  if (e.button === 0) {
    leftMouseDown = false;
  }
  if (e.button === 2) rightMouseDown = false;
});

canvas.addEventListener('mouseleave', () => {
  rightMouseDown = false;
  leftMouseDown = false;
});

canvas.addEventListener('contextmenu', (e) => e.preventDefault());

canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  if (shopMenuOpen) return;
  if (e.deltaY > 0) {
    selectedSlot = (selectedSlot + 1) % 9;
  } else {
    selectedSlot = (selectedSlot - 1 + 9) % 9;
  }
});

function isShipInWarpGate() {
  const STRUCTURE_SIZE = 40;
  const WARP_GATE_DASHED_EXTRA = 80;
  const interactRadius = STRUCTURE_SIZE + WARP_GATE_DASHED_EXTRA;
  for (const st of structures) {
    if (st.type !== 'warpgate') continue;
    const dx = ship.x - st.x;
    const dy = ship.y - st.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < interactRadius) return true;
  }
  return false;
}

function isShipInShop() {
  const STRUCTURE_SIZE = 40;
  const SHOP_DASHED_EXTRA = 80;
  const interactRadius = STRUCTURE_SIZE + SHOP_DASHED_EXTRA;
  for (const st of structures) {
    if (st.type !== 'shop') continue;
    const dx = ship.x - st.x;
    const dy = ship.y - st.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < interactRadius) return true;
  }
  return false;
}

function hasCuprite() {
  for (let i = 0; i < hotbar.length; i++) {
    if (hotbar[i] && hotbar[i].item === 'cuprite' && hotbar[i].quantity > 0) return true;
  }
  return false;
}

function hasEmptyHotbarSlot() {
  for (let i = 0; i < hotbar.length; i++) {
    if (!hotbar[i]) return true;
  }
  return false;
}

// Shop: buy inventory (3x3 grid, items don't restock) and sell prices
const ITEM_BUY_PRICE = { 'energy cell': 3, 'fuel can': 5, 'mining laser': 15 };
const ITEM_SELL_PRICE = { cuprite: 1, 'mining laser': 10, 'fuel can': 2 };
const shopBuySlots = [null, null, null, null, null, null, null, null, null]; // 9 buy slots
const shopSellSlots = [null, null, null, null, null, null, null, null, null]; // 9 sell slots

function initShopBuySlots() {
  // Top/middle rows: energy cells; bottom row: fuel cans
  for (let i = 0; i < 6; i++) {
    shopBuySlots[i] = { item: 'energy cell', energy: 10, maxEnergy: 10 };
  }
  for (let i = 6; i < 9; i++) {
    shopBuySlots[i] = { item: 'fuel can', fuel: 10, maxFuel: 10 };
  }
}

function getShopItemPayload(itemKey) {
  if (itemKey === 'energy cell') {
    return { item: 'energy cell', energy: 10, maxEnergy: 10 };
  }
  return { item: itemKey };
}

function getItemLabel(it) {
  if (!it) return '';
  if (it.item === 'mining laser') return 'L';
  if (it.item === 'energy cell') return 'E';
  if (it.item === 'fuel can') return 'F';
  if (it.item === 'cuprite') return 'C';
  return (it.item && it.item.charAt(0).toUpperCase()) || '';
}

function getSlotHTML(it) {
  let html = '';
  if (it) {
    html += `<span class="slot-icon">${getItemLabel(it)}</span>`;
    
    // Mining laser: heat bar (red)
    if (it.item === 'mining laser' && it.heat != null) {
      const fillH = Math.round(32 * it.heat);
      html += `<div class="slot-bar"><div class="slot-bar-fill" style="height:${fillH}px;background:#cc2222;"></div></div>`;
    }
    
    // Energy cell: energy value + charge bar
    if (it.energy != null) {
      html += `<span class="slot-energy">${it.energy.toFixed(1)}</span>`;
      const charge = it.maxEnergy > 0 ? it.energy / it.maxEnergy : 0;
      const fillH = Math.round(32 * charge);
      const color = charge > 0.5 ? '#66ff66' : (charge > 0.25 ? '#ffff66' : '#ff6666');
      html += `<div class="slot-bar"><div class="slot-bar-fill" style="height:${fillH}px;background:${color};"></div></div>`;
    } else if (it.fuel != null) {
      // Fuel cell: fuel value + charge bar (orange)
      html += `<span class="slot-energy">${it.fuel.toFixed(1)}</span>`;
      const charge = it.maxFuel > 0 ? it.fuel / it.maxFuel : 0;
      const fillH = Math.round(32 * charge);
      const color = charge > 0.5 ? '#ffaa44' : (charge > 0.25 ? '#ffcc66' : '#ff8844');
      html += `<div class="slot-bar"><div class="slot-bar-fill" style="height:${fillH}px;background:${color};"></div></div>`;
    } else if (it.quantity != null && it.quantity > 1) {
      html += `<span class="slot-qty">${it.quantity}</span>`;
    }
  }
  return html;
}

function getItemSellPrice(item) {
  if (!item) return 0;
  // Energy cell: 3 when full, 2 when >50%, 1 when <=50%
  if (item.item === 'energy cell' && item.energy != null && item.maxEnergy != null) {
    const chargeRatio = item.maxEnergy > 0 ? item.energy / item.maxEnergy : 0;
    if (chargeRatio >= 1) return 3;
    if (chargeRatio > 0.5) return 2;
    return 1;
  }
  // Fuel cell: 2 when full, 1 when >0
  if (item.item === 'fuel can' && item.fuel != null && item.maxFuel != null) {
    const chargeRatio = item.maxFuel > 0 ? item.fuel / item.maxFuel : 0;
    if (chargeRatio > 0.5) return 2;
    if (chargeRatio > 0) return 1;
    return 0;
  }
  // Static prices for other items
  const price = ITEM_SELL_PRICE[item.item];
  return price != null ? price : 0;
}

function getSellTotal() {
  let total = 0;
  for (const slot of shopSellSlots) {
    if (!slot) continue;
    const price = getItemSellPrice(slot);
    const qty = slot.quantity != null ? slot.quantity : 1;
    total += price * qty;
  }
  return total;
}

function syncShopBuyArea() {
  for (let i = 0; i < 9; i++) {
    const el = document.querySelector(`#shop-buy-slots .shop-buy-slot[data-buy-slot="${i}"]`);
    if (!el) continue;
    const it = shopBuySlots[i];
    el.classList.toggle('has-item', !!it);
    
    // We can reuse getSlotHTML, but buy slots don't usually need dynamic heat/energy bars if they are static store items.
    // However, our shop items DO have energy/maxEnergy properties (like energy cells).
    // So getSlotHTML works fine.
    
    el.innerHTML = getSlotHTML(it);
  }
  
  // Build price list (unchanged)
  const priceList = document.getElementById('shop-price-list');
  if (priceList) {
    const itemNames = { 'energy cell': 'Energy Cell', 'fuel can': 'Fuel Can', 'mining laser': 'Mining Laser', cuprite: 'Cuprite' };
    let html = '';
    for (const [itemKey, price] of Object.entries(ITEM_BUY_PRICE)) {
      const label = itemNames[itemKey] || itemKey;
      html += `<div class="price-row"><span class="price-label">${label}</span><span class="price-value">${price} cr</span></div>`;
    }
    priceList.innerHTML = html;
  }
}


function updateHUD() {
  // Sync Hotbar
  for (let i = 0; i < 9; i++) {
    const el = document.querySelector(`#hotbar .slot[data-slot="${i}"]`);
    if (!el) continue;
    const it = hotbar[i];
    el.classList.toggle('has-item', !!it);
    el.classList.toggle('selected', i === selectedSlot);
    
    let html = `<span class="slot-num">${i + 1}</span>`;
    html += getSlotHTML(it);
    el.innerHTML = html;
  }
  
  // Sync Credits
  const valueEl = document.querySelector('.credits-value');
  if (valueEl) valueEl.textContent = player.credits;
}

// Alias for compatibility if needed, or I can replace calls
const syncShopHotbar = updateHUD;
const syncShopCredits = updateHUD;

function syncShopSellArea() {
  for (let i = 0; i < 9; i++) {
    const el = document.querySelector(`#shop-sell-slots .shop-sell-slot[data-sell-slot="${i}"]`);
    if (!el) continue;
    const it = shopSellSlots[i];
    el.classList.toggle('has-item', !!it);
    
    el.innerHTML = getSlotHTML(it);
  }
  const totalEl = document.getElementById('shop-sell-total');
  if (totalEl) totalEl.textContent = `Total: ${getSellTotal()} credits`;
  const sellBtn = document.getElementById('shop-sell-btn');
  if (sellBtn) sellBtn.disabled = getSellTotal() === 0;
}

// syncShopCredits merged into updateHUD


function returnSellAreaToHotbar() {
  for (let i = 0; i < shopSellSlots.length; i++) {
    const it = shopSellSlots[i];
    if (!it) continue;
    const qty = it.quantity != null ? it.quantity : 1;
    if (ORE_ITEMS.includes(it.item)) {
      addToInventory(it.item, qty);
    } else {
      for (let k = 0; k < qty; k++) {
        const payload = { ...it };
        if (payload.quantity != null) delete payload.quantity;
        for (let j = 0; j < hotbar.length; j++) {
          if (!hotbar[j]) {
            hotbar[j] = { ...payload };
            break;
          }
        }
      }
    }
    shopSellSlots[i] = null;
  }
  syncShopSellArea();
}

window.addEventListener('keydown', (e) => {
  if (e.key === 'Control') ctrlBrake = true;
  // Hotbar slot selection (1-9)
  if (e.key >= '1' && e.key <= '9') {
    selectedSlot = parseInt(e.key) - 1;
  }
  // Key in E position (KeyE): close shop, or open warp gate/shop menu when inside
  if (e.code === 'KeyE') {
    if (shopMenuOpen) {
      e.preventDefault();
      closeShopMenu();
    } else if (!warpMenuOpen && !gamePaused && isShipInWarpGate()) {
      e.preventDefault();
      gamePaused = true;
      warpMenuOpen = true;
      const overlay = document.getElementById('warp-menu-overlay');
      if (overlay) overlay.style.display = 'flex';
      const payBtn = document.getElementById('warp-pay-btn');
      if (payBtn) payBtn.disabled = player.credits < 100;
    } else if (!warpMenuOpen && !gamePaused && isShipInShop()) {
      e.preventDefault();
      openShopMenu();
    }
  }
});
window.addEventListener('keyup', (e) => {
  if (e.key === 'Control') ctrlBrake = false;
});

// Load level from JSON file
function loadLevel(levelData) {
  levelWidth = levelData.width || 10000;
  levelHeight = levelData.height || 10000;
  asteroids = (levelData.asteroids || []).map(ast => ({
    ...ast,
    health: ast.health ?? ast.radius // health defaults to radius if not specified
  }));
  structures = levelData.structures || [];
  floatingItems.length = 0; // Clear floating items on level load
  // Regenerate stars: same density as a 3000x3000 level, using level seed for reproducibility
  const seed = levelData.seed != null ? levelData.seed : 0;
  const rng = createSeededRandom(typeof seed === 'number' ? seed >>> 0 : 0);
  const REFERENCE_AREA = 3000 * 3000;
  const numStars = Math.round(NUM_STARS * (levelWidth * levelHeight) / REFERENCE_AREA);
  stars.length = 0;
  const spread = Math.max(levelWidth, levelHeight) / 2;
  for (let i = 0; i < numStars; i++) {
    stars.push({
      x: (rng() - 0.5) * 2 * spread,
      y: (rng() - 0.5) * 2 * spread,
      size: rng() * 2 + 0.5,
      brightness: 0.3 + rng() * 0.7
    });
  }
}

// Level select: known levels (in levels folder) + levels loaded via file picker
const KNOWN_LEVELS = [
  { name: 'Level 1', path: 'levels/level1.json' },
  { name: 'Debug', path: 'levels/debug.json' }
];
const loadedLevels = []; // { name, data } for levels loaded via L
const LEVEL_SELECT_KEY = 'spacejam-level-select';
const LEVEL_LOADED_DATA_KEY = 'spacejam-loaded-level-data';

function refreshLevelSelect(selectedValue) {
  const sel = document.getElementById('level-select');
  if (!sel) return;
  sel.textContent = '';
  KNOWN_LEVELS.forEach((lev, i) => {
    const opt = document.createElement('option');
    opt.value = 'known-' + i;
    opt.textContent = lev.name;
    sel.appendChild(opt);
  });
  loadedLevels.forEach((lev, i) => {
    const opt = document.createElement('option');
    opt.value = 'loaded-' + i;
    opt.textContent = lev.name;
    sel.appendChild(opt);
  });
  if (selectedValue != null) sel.value = selectedValue;
}

function saveLevelSelection(value) {
  try {
    if (value.startsWith('loaded-')) {
      localStorage.setItem(LEVEL_SELECT_KEY, 'loaded');
      const i = parseInt(value.split('-')[1], 10);
      if (loadedLevels[i]) localStorage.setItem(LEVEL_LOADED_DATA_KEY, JSON.stringify(loadedLevels[i].data));
    } else {
      localStorage.setItem(LEVEL_SELECT_KEY, value);
      localStorage.removeItem(LEVEL_LOADED_DATA_KEY);
    }
  } catch (e) {}
}

function loadLevelFromSelect(value) {
  if (!value) return;
  saveLevelSelection(value);
  if (value.startsWith('loaded-')) {
    const i = parseInt(value.split('-')[1], 10);
    if (loadedLevels[i]) loadLevel(loadedLevels[i].data);
  } else if (value.startsWith('known-')) {
    const i = parseInt(value.split('-')[1], 10);
    const lev = KNOWN_LEVELS[i];
    if (lev) {
      fetch(lev.path)
        .then(res => res.json())
        .then(level => loadLevel(level))
        .catch(err => console.log('Failed to load ' + lev.path));
    }
  }
}

const levelSelect = document.getElementById('level-select');
if (levelSelect) {
  levelSelect.addEventListener('change', () => loadLevelFromSelect(levelSelect.value));
  // Restore saved level or default to Level 1
  const saved = localStorage.getItem(LEVEL_SELECT_KEY);
  if (saved === 'loaded') {
    try {
      const dataStr = localStorage.getItem(LEVEL_LOADED_DATA_KEY);
      if (dataStr) {
        const data = JSON.parse(dataStr);
        loadedLevels.push({ name: 'Saved level', data });
        refreshLevelSelect('loaded-0');
        loadLevel(data);
      } else {
        refreshLevelSelect('known-0');
        fetch('levels/level1.json').then(res => res.json()).then(level => loadLevel(level)).catch(() => {});
      }
    } catch (e) {
      refreshLevelSelect('known-0');
      fetch('levels/level1.json').then(res => res.json()).then(level => loadLevel(level)).catch(() => {});
    }
  } else if (saved === 'known-0' || saved === 'known-1') {
    refreshLevelSelect(saved);
    const i = parseInt(saved.split('-')[1], 10);
    const lev = KNOWN_LEVELS[i];
    if (lev) fetch(lev.path).then(res => res.json()).then(level => loadLevel(level)).catch(() => {});
  } else {
    refreshLevelSelect('known-0');
    fetch('levels/level1.json').then(res => res.json()).then(level => loadLevel(level)).catch(() => {});
  }
}

// File input for loading levels
const levelInput = document.createElement('input');
levelInput.type = 'file';
levelInput.accept = '.json';
levelInput.style.display = 'none';
document.body.appendChild(levelInput);

levelInput.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const level = JSON.parse(ev.target.result);
      loadedLevels.push({ name: file.name.replace(/\.json$/i, '') || file.name, data: level });
      const loadedValue = 'loaded-' + (loadedLevels.length - 1);
      refreshLevelSelect(loadedValue);
      saveLevelSelection(loadedValue);
      loadLevel(level);
    } catch (err) {
      console.error('Invalid level file');
    }
  };
  reader.readAsText(file);
  e.target.value = '';
});

// Press L to load a level file
window.addEventListener('keydown', (e) => {
  if (e.key === 'l' || e.key === 'L') {
    levelInput.click();
  }
});

function closeWarpMenu() {
  warpMenuOpen = false;
  gamePaused = warpMenuOpen || shopMenuOpen;
  const overlay = document.getElementById('warp-menu-overlay');
  if (overlay) overlay.style.display = 'none';
}

function openShopMenu() {
  gamePaused = true;
  shopMenuOpen = true;
  for (let i = 0; i < shopSellSlots.length; i++) shopSellSlots[i] = null;
  syncShopBuyArea();
  updateHUD();
  syncShopSellArea();
  const overlay = document.getElementById('shop-menu-overlay');
  if (overlay) overlay.style.display = 'flex';
  const ghost = document.getElementById('shop-drag-ghost');
  if (ghost) ghost.style.display = 'none';
}

function closeShopMenu() {
  returnSellAreaToHotbar();
  shopMenuOpen = false;
  gamePaused = warpMenuOpen || shopMenuOpen;
  const overlay = document.getElementById('shop-menu-overlay');
  if (overlay) overlay.style.display = 'none';
  const ghost = document.getElementById('shop-drag-ghost');
  if (ghost) ghost.style.display = 'none';
}

const warpMenuOverlay = document.getElementById('warp-menu-overlay');
const warpPayBtn = document.getElementById('warp-pay-btn');
const warpCancelBtn = document.getElementById('warp-cancel-btn');
if (warpCancelBtn) {
  warpCancelBtn.addEventListener('click', () => closeWarpMenu());
}
if (warpPayBtn) {
  warpPayBtn.addEventListener('click', () => {
    if (player.credits >= 100) {
      player.credits -= 100;
      closeWarpMenu();
    }
  });
}

const shopCloseBtn = document.getElementById('shop-close-btn');
if (shopCloseBtn) {
  shopCloseBtn.addEventListener('click', () => closeShopMenu());
}

const shopSellBtn = document.getElementById('shop-sell-btn');
if (shopSellBtn) {
  shopSellBtn.addEventListener('click', () => {
    const total = getSellTotal();
    if (total <= 0) return;
    player.credits += total;
    for (let i = 0; i < shopSellSlots.length; i++) shopSellSlots[i] = null;
    syncShopSellArea();
    updateHUD();
  });
}

// Inventory drag state (unified for HUD and Shop)
let inventoryDrag = null; // { kind: 'hotbar'|'buy'|'sell', fromSlot?: number, fromBuySlot?: number, fromSellSlot?: number, price?: number }

function setDragGhostVisible(visible) {
  const ghost = document.getElementById('shop-drag-ghost');
  if (!ghost) return;
  ghost.style.display = visible ? 'flex' : 'none';
}

function setDragGhostContent(label, qtyText) {
  const ghost = document.getElementById('shop-drag-ghost');
  if (!ghost) return;
  if (qtyText) {
    ghost.innerHTML = `${label}<span class="slot-qty">${qtyText}</span>`;
  } else {
    ghost.textContent = label;
  }
}

function setDragGhostPos(clientX, clientY) {
  const ghost = document.getElementById('shop-drag-ghost');
  if (!ghost) return;
  ghost.style.left = (clientX - 22) + 'px';
  ghost.style.top = (clientY - 22) + 'px';
}

function beginDragFromHotbar(slotIndex, clientX, clientY) {
  const it = hotbar[slotIndex];
  if (!it) return;
  inventoryDrag = { kind: 'hotbar', fromSlot: slotIndex };
  const qty = it.quantity != null ? String(it.quantity) : (it.energy != null ? String(Math.round(it.energy)) : (it.fuel != null ? String(Math.round(it.fuel)) : ''));
  setDragGhostContent(getItemLabel(it), qty);
  setDragGhostPos(clientX, clientY);
  setDragGhostVisible(true);
}

function beginDragFromBuy(buyIndex, clientX, clientY) {
  const it = shopBuySlots[buyIndex];
  if (!it) return;
  const price = ITEM_BUY_PRICE[it.item] || 0;
  inventoryDrag = { kind: 'buy', fromBuySlot: buyIndex, price };
  const qty = it.quantity != null ? String(it.quantity) : (it.energy != null ? String(Math.round(it.energy)) : (it.fuel != null ? String(Math.round(it.fuel)) : ''));
  setDragGhostContent(getItemLabel(it), qty);
  setDragGhostPos(clientX, clientY);
  setDragGhostVisible(true);
}

function beginDragFromSell(sellIndex, clientX, clientY) {
  const it = shopSellSlots[sellIndex];
  if (!it) return;
  inventoryDrag = { kind: 'sell', fromSellSlot: sellIndex };
  const qty = it.quantity != null ? String(it.quantity) : (it.energy != null ? String(Math.round(it.energy)) : (it.fuel != null ? String(Math.round(it.fuel)) : ''));
  setDragGhostContent(getItemLabel(it), qty);
  setDragGhostPos(clientX, clientY);
  setDragGhostVisible(true);
}

function endDrag(clientX, clientY) {
  const drag = inventoryDrag;
  inventoryDrag = null;
  setDragGhostVisible(false);
  // Remove fuel bar highlight
  const fuelBarEl = document.getElementById('fuel-bar-drop-zone');
  if (fuelBarEl) fuelBarEl.classList.remove('highlight');
  if (!drag) return;

  const under = document.elementFromPoint(clientX, clientY);
  // Check if we are over a slot or the fuel bar
  let targetSlotEl = null;
  const isOverFuelBar = under && under.closest('#fuel-bar-drop-zone');
  if (under) {
    targetSlotEl = under.closest('.slot') || under.closest('.shop-buy-slot') || under.closest('.shop-sell-slot');
  }

  // Handle drop on fuel bar: fuel can adds 10 fuel
  if (isOverFuelBar && drag.kind === 'hotbar') {
    const from = drag.fromSlot;
    const it = hotbar[from];
    if (it && it.item === 'fuel can') {
      player.fuel = Math.min(player.maxFuel, player.fuel + 10);
      hotbar[from] = null;
      updateHUD();
      return;
    }
  }

  // Handle Jettison if dropped outside of UI and shop is closed
  if (!targetSlotEl && !shopMenuOpen && drag.kind === 'hotbar') {
    // Drop into space
    const from = drag.fromSlot;
    const it = hotbar[from];
    if (it) {
      const dx = mouseX - WIDTH / 2;
      const dy = mouseY - HEIGHT / 2;
      const dir = normalize(dx, dy);
      if (dir.x !== 0 || dir.y !== 0) {
        const jettSpeed = 240;
        const floatItem = {
          x: ship.x + dir.x * 20,
          y: ship.y + dir.y * 20,
          vx: dir.x * jettSpeed + ship.vx * 0.3,
          vy: dir.y * jettSpeed + ship.vy * 0.3,
          item: it.item,
          quantity: it.quantity || 1
        };
        if (it.energy != null) {
          floatItem.energy = it.energy;
          floatItem.maxEnergy = it.maxEnergy;
        }
        if (it.fuel != null) {
          floatItem.fuel = it.fuel;
          floatItem.maxFuel = it.maxFuel;
        }
        if (it.heat != null) {
          floatItem.heat = it.heat;
          floatItem.overheated = !!it.overheated;
        }
        floatingItems.push(floatItem);
        hotbar[from] = null;
        updateHUD();
      }
    }
    return;
  }

  if (!targetSlotEl) return;

  // Determine target type
  const isHotbar = targetSlotEl.classList.contains('slot');
  const isSell = targetSlotEl.classList.contains('shop-sell-slot');
  const isBuy = targetSlotEl.classList.contains('shop-buy-slot'); // Can't drop onto buy slots generally

  if (drag.kind === 'hotbar') {
    const from = drag.fromSlot;
    const it = hotbar[from];
    if (!it) return;

    if (isSell && shopMenuOpen) {
      const sellIndex = parseInt(targetSlotEl.dataset.sellSlot, 10);
      if (sellIndex >= 0 && !shopSellSlots[sellIndex]) {
        shopSellSlots[sellIndex] = { ...it };
        hotbar[from] = null;
        updateHUD();
        syncShopSellArea();
        return;
      }
    } else if (isHotbar) {
      const to = parseInt(targetSlotEl.dataset.slot, 10);
      if (to >= 0 && to !== from) {
        const tmp = hotbar[to];
        hotbar[to] = hotbar[from];
        hotbar[from] = tmp;
        updateHUD();
        return;
      }
    }
  } else if (drag.kind === 'buy') {
    if (!isHotbar) return;
    const from = drag.fromBuySlot;
    const it = shopBuySlots[from];
    if (!it) return;
    const to = parseInt(targetSlotEl.dataset.slot, 10);
    if (to < 0) return;
    if (hotbar[to]) return;
    if (player.credits < drag.price) return;
    player.credits -= drag.price;
    hotbar[to] = { ...it };
    shopBuySlots[from] = null;
    syncShopBuyArea();
    updateHUD();
  } else if (drag.kind === 'sell') {
    const from = drag.fromSellSlot;
    const it = shopSellSlots[from];
    if (!it) return;
    
    if (isHotbar) {
      const to = parseInt(targetSlotEl.dataset.slot, 10);
      if (to >= 0 && !hotbar[to]) {
        hotbar[to] = { ...it };
        shopSellSlots[from] = null;
        updateHUD();
        syncShopSellArea();
        return;
      }
    } else if (isSell) {
      const toSell = parseInt(targetSlotEl.dataset.sellSlot, 10);
      if (toSell >= 0 && toSell !== from) {
        const tmp = shopSellSlots[toSell];
        shopSellSlots[toSell] = shopSellSlots[from];
        shopSellSlots[from] = tmp;
        syncShopSellArea();
        return;
      }
    }
  }
}

// UI Drag Start Listener
window.addEventListener('mousedown', (e) => {
  if (e.button !== 0) return;
  const t = e.target;
  
  const hotbarSlotEl = t.closest && t.closest('#hotbar .slot');
  const buySlotEl = t.closest && t.closest('.shop-buy-slot');
  const sellSlotEl = t.closest && t.closest('.shop-sell-slot');
  
  if (hotbarSlotEl) {
    const slotIndex = parseInt(hotbarSlotEl.dataset.slot, 10);
    if (slotIndex >= 0 && hotbar[slotIndex]) {
      e.preventDefault();
      beginDragFromHotbar(slotIndex, e.clientX, e.clientY);
    }
    return;
  }
  
  if (shopMenuOpen) {
    if (buySlotEl) {
      const buyIndex = parseInt(buySlotEl.dataset.buySlot, 10);
      if (buyIndex >= 0 && shopBuySlots[buyIndex]) {
        e.preventDefault();
        beginDragFromBuy(buyIndex, e.clientX, e.clientY);
      }
      return;
    }
    if (sellSlotEl) {
      const sellIndex = parseInt(sellSlotEl.dataset.sellSlot, 10);
      if (sellIndex >= 0 && shopSellSlots[sellIndex]) {
        e.preventDefault();
        beginDragFromSell(sellIndex, e.clientX, e.clientY);
      }
      return;
    }
  }
});

window.addEventListener('mousemove', (e) => {
  if (inventoryDrag) {
    setDragGhostPos(e.clientX, e.clientY);
    // Highlight fuel bar if dragging a fuel can over it
    const fuelBarEl = document.getElementById('fuel-bar-drop-zone');
    if (fuelBarEl) {
      let isDraggingFuelCan = false;
      if (inventoryDrag.kind === 'hotbar') {
        const it = hotbar[inventoryDrag.fromSlot];
        if (it && it.item === 'fuel can') isDraggingFuelCan = true;
      }
      if (isDraggingFuelCan) {
        const under = document.elementFromPoint(e.clientX, e.clientY);
        if (under && under.closest('#fuel-bar-drop-zone')) {
          fuelBarEl.classList.add('highlight');
        } else {
          fuelBarEl.classList.remove('highlight');
        }
      } else {
        fuelBarEl.classList.remove('highlight');
      }
    }
  }
});

window.addEventListener('mouseup', (e) => {
  if (e.button !== 0) return;
  if (inventoryDrag) {
    endDrag(e.clientX, e.clientY);
  }
});

// Game loop
let lastTime = performance.now();
initStars();
initShopBuySlots();

// Initial level load is handled in level select init above (restore saved or level1)

function gameLoop(now) {
  const dt = Math.min((now - lastTime) / 1000, 0.1);
  lastTime = now;

  if (!gamePaused) update(dt);
  render();
  updateHUD(); // Sync HUD every frame (or could optimize to only when changed)

  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

```

