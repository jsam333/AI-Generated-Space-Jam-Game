Enter your prompt here

# Project Structure

â”œâ”€ ðŸ“ levels
  â””â”€ level2.json
  â””â”€ level1.json
  â””â”€ debug.json
â”œâ”€ ðŸ“ js
  â””â”€ utils.js
  â””â”€ ship.js
  â””â”€ main.js
  â””â”€ input.js
  â””â”€ game.js
  â””â”€ game-state.js
  â””â”€ editor.js
  â””â”€ constants.js
â”œâ”€ ðŸ“ css
  â””â”€ editor.css
  â””â”€ style.css
â”œâ”€ ðŸ“ assets
  â””â”€ large-asteroid1.glb
  â””â”€ ore.glb
  â””â”€ ore old.glb
  â””â”€ medium-asteroid2.glb
  â””â”€ medium-asteroid1.glb
  â””â”€ pirate-base.glb
  â””â”€ shop.glb
  â””â”€ scrap.glb
  â””â”€ scrap old.glb
  â””â”€ scout-ship.glb
  â””â”€ pirate.glb
  â””â”€ small-asteroid2.glb
  â””â”€ small-asteroid1.glb
  â””â”€ small-asteroid1 (old).glb
  â””â”€ small-asteroid3.glb
  â””â”€ warp-gate.glb
  â””â”€ pirate old.glb
â”œâ”€ ðŸ“ backup levels
  â””â”€ level1.json
  â””â”€ debug.json
  â””â”€ level2.json
â”œâ”€ ðŸ“ vendor
  â”œâ”€ ðŸ“ three
    â”œâ”€ ðŸ“ examples
      â”œâ”€ ðŸ“ jsm
        â”œâ”€ ðŸ“ utils
          â””â”€ BufferGeometryUtils.js
        â”œâ”€ ðŸ“ loaders
          â””â”€ GLTFLoader.js
â””â”€ index.html
â””â”€ editor.html


# Project Files

- c:\Users\jsamu\Cursor projects\AI Generated Space Jam\js\constants.js
- c:\Users\jsamu\Cursor projects\AI Generated Space Jam\js\utils.js
- c:\Users\jsamu\Cursor projects\AI Generated Space Jam\js\input.js
- c:\Users\jsamu\Cursor projects\AI Generated Space Jam\js\ship.js
- c:\Users\jsamu\Cursor projects\AI Generated Space Jam\js\game-state.js
- c:\Users\jsamu\Cursor projects\AI Generated Space Jam\js\game.js

## c:\Users\jsamu\Cursor projects\AI Generated Space Jam\js\constants.js
```
export const WIDTH = 1200;
export const HEIGHT = 900;

// Physics
export const ACCEL = 150;
export const FRICTION = 0.15;
export const MAX_SPEED = 175; // Base max speed
export const BRAKE_FRICTION = 1.5;

// Pirates
export const PIRATE_ACCEL = 150;
export const PIRATE_FRICTION = 0.15;
export const PIRATE_MAX_SPEED = 160;
export const PIRATE_HEALTH = 20;
export const PIRATE_BULLET_SPEED = 250;

// Combat
export const BULLET_SPEED = 500;
export const FIRE_COOLDOWN = 0.03;
export const WEAPON_ENERGY_DRAIN = 1;
export const LASER_HEAT_RATE = 1;
export const LASER_COOL_RATE = 1 / 3;
export const BLASTER_ENERGY_PER_SHOT = 0.2;
export const BLASTER_HEAT_PER_SHOT = 0.09;
export const BLASTER_COOL_RATE = 1 / 3;
export const BLASTER_FIRE_RATE = 10;
export const SHOT_SPREAD = 8;

// Ship
export const SHIP_SIZE = 10;
export const SHIP_COLLISION_RADIUS = 8;
export const SHIP_COLLECTION_RADIUS = 16;

// Player Stats
export const OXYGEN_DEPLETION_RATE = 1 / 25;
export const FUEL_DEPLETION_RATE = 1 / 3;

// Inventory
export const MAX_ORE_STACK = 10;
export const ORE_ITEMS = ['cuprite', 'hematite', 'aurite', 'diamite', 'platinite', 'scrap'];

export const MINING_LASER_STATS = {
  'mining laser':       { heatRate: 1, coolRate: 1 / 3, dps: 7, energyDrain: 1 },
  'medium mining laser': { heatRate: 1 / 1.5, coolRate: 1 / 3, dps: 10, energyDrain: 1.5 }
};

// Colors
export const COLORS = {
    BACKGROUND: '#1a1a1a', // from CSS
    TEXT_WHITE: '#fff',
    TEXT_YELLOW: '#ffcc00',
    TEXT_RED: '#ff3333'
};

// Starfield
export const NUM_STARS = 2400;

// Item Images
export const ITEM_IMAGES = {
  'fuel tank': new Image(),
  'small energy cell': new Image(),
  'medium energy cell': new Image(),
  'oxygen canister': new Image()
};
ITEM_IMAGES['fuel tank'].src = 'assets/fuel-can.png';
ITEM_IMAGES['small energy cell'].src = 'assets/energy-cell.png';
ITEM_IMAGES['medium energy cell'].src = 'assets/energy-cell.png';
ITEM_IMAGES['oxygen canister'].src = 'assets/oxygen-can.png';
ITEM_IMAGES['health pack'] = ITEM_IMAGES['oxygen canister'];
ITEM_IMAGES['large health pack'] = ITEM_IMAGES['oxygen canister'];
ITEM_IMAGES['large fuel tank'] = ITEM_IMAGES['fuel tank'];
ITEM_IMAGES['large oxygen canister'] = ITEM_IMAGES['oxygen canister'];

const laserImg = new Image();
laserImg.src = 'assets/laser.png';
ITEM_IMAGES['mining laser'] = laserImg;
ITEM_IMAGES['medium mining laser'] = laserImg;

const blasterImg = new Image();
blasterImg.src = 'assets/blaster.png';
ITEM_IMAGES['light blaster'] = blasterImg;

```

## c:\Users\jsamu\Cursor projects\AI Generated Space Jam\js\utils.js
```
import { ITEM_IMAGES } from './constants.js';

export function createSeededRandom(seed) {
  return function () {
    let t = (seed += 0x6d2b79f5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

export function getItemImagePath(itemName) {
  if (itemName === 'oxygen canister' || itemName === 'large oxygen canister') return 'assets/oxygen-can.png';
  if (itemName === 'fuel tank' || itemName === 'large fuel tank') return 'assets/fuel-can.png';
  if (itemName === 'health pack' || itemName === 'large health pack') return 'assets/oxygen-can.png';
  if (itemName === 'small energy cell' || itemName === 'medium energy cell') return 'assets/energy-cell.png';
  if (itemName === 'mining laser' || itemName === 'medium mining laser') return 'assets/laser.png';
  if (itemName === 'light blaster') return 'assets/blaster.png';
  return null;
}

export function normalize(x, y) {
  const len = Math.sqrt(x * x + y * y);
  if (len === 0) return { x: 0, y: 0 };
  return { x: x / len, y: y / len };
}

export function worldToScreen(wx, wy, shipX, shipY, screenW, screenH) {
  return {
    x: wx - shipX + screenW / 2,
    y: wy - shipY + screenH / 2
  };
}

export function screenToWorld(sx, sy, shipX, shipY, screenW, screenH) {
    return {
        x: sx - screenW / 2 + shipX,
        y: sy - screenH / 2 + shipY
    };
}

export function spawnSparks(x, y, count, particlesContainer) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 50 + Math.random() * 150;
    const life = 0.2 + Math.random() * 0.3; // 0.2-0.5 seconds
    particlesContainer.push({
      x: x,
      y: y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life,
      maxLife: life,
      size: 1 + Math.random() * 2
    });
  }
}

```

## c:\Users\jsamu\Cursor projects\AI Generated Space Jam\js\input.js
```
export class InputManager {
    constructor(canvas, width, height) {
        this.canvas = canvas;
        this.width = width;
        this.height = height;
        
        this.mouse = { x: width / 2, y: height / 2, left: false, right: false };
        this.keys = { ctrl: false };
        
        this.listeners = {};
        
        this.init();
    }

    init() {
        // Mouse Events
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
        this.canvas.addEventListener('mouseleave', () => this.onMouseLeave());
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        this.canvas.addEventListener('wheel', (e) => this.emit('wheel', e));

        // Keyboard Events
        window.addEventListener('keydown', (e) => this.onKeyDown(e));
        window.addEventListener('keyup', (e) => this.onKeyUp(e));
        window.addEventListener('mousedown', (e) => this.onWindowMouseDown(e));
        window.addEventListener('mousemove', (e) => this.onWindowMouseMove(e));
        window.addEventListener('mouseup', (e) => this.onWindowMouseUp(e));
    }

    on(event, callback) {
        if (!this.listeners[event]) {
            this.listeners[event] = [];
        }
        this.listeners[event].push(callback);
    }

    emit(event, data) {
        if (this.listeners[event]) {
            this.listeners[event].forEach(cb => cb(data));
        }
    }

    onMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        this.mouse.x = (e.clientX - rect.left) * (this.width / rect.width);
        this.mouse.y = (e.clientY - rect.top) * (this.height / rect.height);
    }

    onMouseDown(e) {
        if (e.button === 0) this.mouse.left = true;
        if (e.button === 2) this.mouse.right = true;
        this.emit('mousedown', e);
    }

    onMouseUp(e) {
        if (e.button === 0) this.mouse.left = false;
        if (e.button === 2) this.mouse.right = false;
        this.emit('mouseup', e);
    }

    onMouseLeave() {
        this.mouse.left = false;
        this.mouse.right = false;
    }

    onKeyDown(e) {
        if (e.key === 'Control') this.keys.ctrl = true;
        
        if (e.key >= '1' && e.key <= '9') {
            this.emit('slot', parseInt(e.key) - 1);
        }
        
        if (e.code === 'KeyE') {
            this.emit('interact', e);
        }

        this.emit('keydown', e);
    }

    onKeyUp(e) {
        if (e.key === 'Control') this.keys.ctrl = false;
        this.emit('keyup', e);
    }

    // Window level mouse events for when cursor leaves canvas but button is held
    onWindowMouseDown(e) {
        // Optional: handle global mouse down if needed
    }

    onWindowMouseMove(e) {
        // Optional: track global mouse if needed
    }

    onWindowMouseUp(e) {
        // If mouse released outside canvas, we should probably clear flags
        if (e.button === 0) this.mouse.left = false;
        if (e.button === 2) this.mouse.right = false;
    }

    reset() {
        this.mouse.left = false;
        this.mouse.right = false;
        this.keys.ctrl = false;
    }
}

```

## c:\Users\jsamu\Cursor projects\AI Generated Space Jam\js\ship.js
```
import { ACCEL, FRICTION, BRAKE_FRICTION, MAX_SPEED, FUEL_DEPLETION_RATE, OXYGEN_DEPLETION_RATE, WIDTH, HEIGHT, SHIP_SIZE } from './constants.js';
import { normalize } from './utils.js';

export class Ship {
    constructor() {
        this.x = 0;
        this.y = 0;
        this.vx = 0;
        this.vy = 0;
        
        // Player stats
        this.health = 50.0;
        this.maxHealth = 50.0;
        this.fuel = 25.0;
        this.maxFuel = 25.0;
        this.oxygen = 30.0;
        this.maxOxygen = 30.0;
        this.credits = 0;
        
        // Render state
        this.tilt = 0;
        this.prevAimAngle = 0;
        this.tiltInitialized = false;
        this.isThrusting = false;

        // 3D components
        this.canvas = null;
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.mesh = null;
        this.modelLoaded = false;
        this.flames = [];
    }

    init3D() {
        if (typeof THREE === 'undefined') return;
        
        this.canvas = document.getElementById('ship-canvas');
        if (!this.canvas) return;

        const aspect = WIDTH / HEIGHT;
        this.camera = new THREE.PerspectiveCamera(15, aspect, 1, 5000);
        this.camera.position.set(0, 0, 3390);
        this.camera.lookAt(0, 0, 0);

        this.scene = new THREE.Scene();
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(10, 20, 30);
        this.scene.add(dirLight);

        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, alpha: true, antialias: true });
        this.renderer.setSize(WIDTH, HEIGHT);
        this.renderer.setPixelRatio(window.devicePixelRatio);

        // Load Model
        const loader = new GLTFLoader();
        loader.load('assets/scout-ship.glb', (gltf) => {
            this.mesh = gltf.scene;
            // Normalize scale
            const box = new THREE.Box3().setFromObject(this.mesh);
            const size = new THREE.Vector3();
            box.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 20 / maxDim;
            this.mesh.scale.set(scale, scale, scale);
            
            // Fix orientation
            this.mesh.rotation.x = Math.PI / 2;
            this.mesh.rotation.y = Math.PI;
            
            this.scene.add(this.mesh);
            this.modelLoaded = true;

            // Thruster flames
            const flameGeo = new THREE.ConeGeometry(0.5, 2, 8);
            const flameMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
            
            // Left flame
            const flame1 = new THREE.Mesh(flameGeo, flameMat);
            flame1.position.set(-2.5, -4, 0.5); 
            flame1.rotation.x = Math.PI;
            this.mesh.add(flame1);
            this.flames.push(flame1);

            // Right flame
            const flame2 = new THREE.Mesh(flameGeo, flameMat);
            flame2.position.set(2.5, -4, 0.5);
            flame2.rotation.x = Math.PI;
            this.mesh.add(flame2);
            this.flames.push(flame2);
        });
    }

    update(dt, input) {
        this.isThrusting = false;
        
        // Thrust
        if (input.mouse.right && this.fuel > 0) {
            const dx = input.mouse.x - WIDTH / 2;
            const dy = input.mouse.y - HEIGHT / 2;
            const dir = normalize(dx, dy);
            
            if (dir.x !== 0 || dir.y !== 0) {
                this.vx += dir.x * ACCEL * dt;
                this.vy += dir.y * ACCEL * dt;
                this.fuel = Math.max(0, this.fuel - FUEL_DEPLETION_RATE * dt);
                this.isThrusting = true;
            }
        }

        // Friction
        const friction = input.keys.ctrl ? BRAKE_FRICTION : FRICTION;
        this.vx *= Math.max(0, 1 - friction * dt);
        this.vy *= Math.max(0, 1 - friction * dt);

        // Max Speed
        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        if (speed > MAX_SPEED) {
            const scale = MAX_SPEED / speed;
            this.vx *= scale;
            this.vy *= scale;
        }

        // Position
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // Oxygen
        this.oxygen = Math.max(0, this.oxygen - OXYGEN_DEPLETION_RATE * dt);
        if (this.oxygen <= 0) {
            this.health = Math.max(0, this.health - 1 * dt);
        }
    }

    draw(ctx, input) {
        const cx = WIDTH / 2;
        const cy = HEIGHT / 2;
        const aimAngle = Math.atan2(input.mouse.y - cy, input.mouse.x - cx);

        if (this.renderer) this.renderer.clear();

        if (this.modelLoaded && this.mesh && this.renderer && this.scene && this.camera) {
            // 3D Render
            if (!this.tiltInitialized) {
                this.prevAimAngle = aimAngle;
                this.tiltInitialized = true;
            }

            let deltaAngle = aimAngle - this.prevAimAngle;
            while (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
            while (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
            this.prevAimAngle = aimAngle;

            const TILT_SENSITIVITY = 8;
            const TILT_DECAY = 4;
            // Use a fixed dt for tilt decay approximation or pass dt to draw? 
            // Ideally update tilt in update(), but aimAngle depends on mouse which is input.
            // For now, assume 1/60s or pass dt. I'll use 1/60 for simplicity or better, pass dt to draw.
            const dt = 1/60; 
            this.tilt += deltaAngle * TILT_SENSITIVITY - this.tilt * TILT_DECAY * dt;
            this.tilt = Math.max(-0.5, Math.min(0.5, this.tilt));

            this.mesh.rotation.y = aimAngle + Math.PI / 2;
            this.mesh.rotation.z = this.tilt;

            // Flames
            for (const flame of this.flames) {
                flame.visible = this.isThrusting;
                flame.rotation.z = this.tilt;
                if (this.isThrusting) {
                    const flicker = 1 + 0.3 * Math.sin(performance.now() * 0.02);
                    flame.scale.set(1, 1, flicker);
                }
            }

            this.renderer.render(this.scene, this.camera);
        } else {
            // 2D Fallback
            this.draw2D(ctx, aimAngle);
        }
    }

    draw2D(ctx, angle) {
        const cx = WIDTH / 2;
        const cy = HEIGHT / 2;
        
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(angle);
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(SHIP_SIZE, 0);
        ctx.lineTo(-SHIP_SIZE * 0.7, SHIP_SIZE * 0.6);
        ctx.lineTo(-SHIP_SIZE * 0.4, 0);
        ctx.lineTo(-SHIP_SIZE * 0.7, -SHIP_SIZE * 0.6);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.restore();
    }
}

```

## c:\Users\jsamu\Cursor projects\AI Generated Space Jam\js\game-state.js
```
export const gameState = {
    asteroids: [],
    structures: [],
    bullets: [],
    particles: [],
    pirates: [],
    floatingItems: [],
    stars: [],
    
    level: {
        width: 10000,
        height: 10000,
        seed: 0,
        elapsedTime: 0,
        isDebug: false,
        spawnSettings: {
            initialDelay: 120,
            waveIntervalMin: 60,
            waveIntervalMax: 100,
            waveSizeMin: 2,
            waveSizeMax: 4,
            tiers: []
        },
        pirateNextWaveTime: 120
    },

    ui: {
        paused: true,
        warpMenuOpen: false,
        shopMenuOpen: false,
        craftingMenuOpen: false,
        shipyardMenuOpen: false,
        startScreenOpen: true,
        deathScreenOpen: false,
        interactPromptAlpha: 0,
        interactPromptTarget: null,
        tutorialTextTimer: 0,
        tutorialTextTimerStarted: false,
        tutorialTextWorldX: 0,
        tutorialTextWorldY: 0,
        activeShopStructure: null,
        activeCraftingStructure: null,
        craftingInputSlots: [null, null, null, null],
        craftingOutputSlot: null
    },

    hotbar: [
        { item: 'mining laser', heat: 0, overheated: false },
        { item: 'small energy cell', energy: 10, maxEnergy: 10 },
        { item: 'small energy cell', energy: 10, maxEnergy: 10 },
        null, null, null, null, null, null
    ],
    selectedSlot: 0,

    reset() {
        this.asteroids.length = 0;
        this.structures.length = 0;
        this.bullets.length = 0;
        this.particles.length = 0;
        this.pirates.length = 0;
        this.floatingItems.length = 0;
        this.stars.length = 0;
        
        this.level.elapsedTime = 0;
        this.level.pirateNextWaveTime = this.level.spawnSettings.initialDelay;
        
        // Reset UI state
        this.ui.paused = true;
        this.ui.warpMenuOpen = false;
        this.ui.shopMenuOpen = false;
        this.ui.craftingMenuOpen = false;
        this.ui.shipyardMenuOpen = false;
        this.ui.startScreenOpen = true;
        this.ui.deathScreenOpen = false;
    }
};

```

## c:\Users\jsamu\Cursor projects\AI Generated Space Jam\js\game.js
```
import { WIDTH, HEIGHT, ITEM_IMAGES, MINING_LASER_STATS, BULLET_SPEED, PIRATE_BULLET_SPEED, FIRE_COOLDOWN, SHOT_SPREAD, SHIP_SIZE, SHIP_COLLISION_RADIUS, SHIP_COLLECTION_RADIUS, ORE_ITEMS, MAX_ORE_STACK, PIRATE_HEALTH, PIRATE_MAX_SPEED, PIRATE_ACCEL, PIRATE_FRICTION } from './constants.js';
import { createSeededRandom, getItemImagePath, spawnSparks as spawnSparksUtil, normalize, worldToScreen } from './utils.js';
import { gameState } from './game-state.js';
import { Ship } from './ship.js';
import { InputManager } from './input.js';

const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');

canvas.width = WIDTH;
canvas.height = HEIGHT;

const ship = new Ship();
const inputManager = new InputManager(canvas, WIDTH, HEIGHT);

// Aliases for compatibility
const asteroids = gameState.asteroids;
const structures = gameState.structures;
const bullets = gameState.bullets;
const particles = gameState.particles;
const pirates = gameState.pirates;
const floatingItems = gameState.floatingItems;
const stars = gameState.stars;
const hotbar = gameState.hotbar;
const player = ship; // player stats are on ship

// 3D Models (View)
let smallAsteroidModels = [null, null, null];
let mediumAsteroidModels = [null, null];
let largeAsteroidModel = null;
let oreModel = null;
let scrapModel = null;
let asteroidContainer = null;
let structureModels = { warpgate: null, shop: null, piratebase: null };
let pirateModel = null;
let pirateContainer = null;
let structureContainer = null;
let floatingOreContainer = null;

let uiCanvas = document.getElementById('ui-canvas');
let uiCtx = uiCanvas ? uiCanvas.getContext('2d') : null;
if (uiCanvas) {
  uiCanvas.width = WIDTH;
  uiCanvas.height = HEIGHT;
}

function spawnSparks(x, y, count) {
    spawnSparksUtil(x, y, count, particles);
}

function getFirstChargedCell() {
  for (let i = 0; i < hotbar.length; i++) {
    const cell = hotbar[i];
    if (cell && (cell.item === 'small energy cell' || cell.item === 'medium energy cell') && cell.energy != null && cell.energy > 0) return cell;
  }
  return null;
}

function getFirstCellWithMinEnergy(min) {
  for (let i = 0; i < hotbar.length; i++) {
    const cell = hotbar[i];
    if (cell && (cell.item === 'small energy cell' || cell.item === 'medium energy cell') && cell.energy != null && cell.energy >= min) return cell;
  }
  return null;
}

// Blaster accumulator
let blasterFireAccum = 0;


let gameState.ui.paused = true;
let gameState.ui.warpMenuOpen = false;
let gameState.ui.shopMenuOpen = false;
let gameState.ui.craftingMenuOpen = false;
let gameState.ui.shipyardMenuOpen = false;
let gameState.ui.startScreenOpen = true;
let gameState.ui.deathScreenOpen = false;
let gameState.ui.interactPromptAlpha = 0; // Fade alpha for interaction prompt (0-1)
let gameState.ui.interactPromptTarget = null; // Current structure showing prompt
let gameState.ui.tutorialTextTimer = 0; // Time remaining for tutorial text (seconds)
let gameState.ui.gameState.ui.tutorialTextTimerStarted = false; // True after player thrusts for the first time
let gameState.ui.tutorialTextWorldX = 0; // World X position of tutorial text
let gameState.ui.tutorialTextWorldY = 0; // World Y position of tutorial text
let gameState.ui.activeShopStructure = null;
let gameState.ui.activeCraftingStructure = null;
const gameState.ui.craftingInputSlots = [null, null, null, null];
let gameState.ui.craftingOutputSlot = null;

// Start screen overlay (click to start). Keep rendering/asset loading running behind it.
const startOverlayEl = document.getElementById('start-menu-overlay');
if (startOverlayEl) {
  startOverlayEl.style.display = 'flex';
  startOverlayEl.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    startOverlayEl.style.display = 'none';
    gameState.ui.startScreenOpen = false;
    // Unpause unless another menu is open (shouldn't be at boot)
    gameState.ui.paused = gameState.ui.warpMenuOpen || gameState.ui.shopMenuOpen || gameState.ui.craftingMenuOpen || gameState.ui.shipyardMenuOpen;
    // Clear latched inputs so the click doesn't immediately fire/thrust
    inputManager.mouse.left = false;
    inputManager.mouse.right = false;
    inputManager.keys.ctrl = false;
    if (canvas && canvas.focus) canvas.focus();
  });
} else {
  // If markup is missing for some reason, don't block the game.
  gameState.ui.startScreenOpen = false;
  gameState.ui.paused = false;
}

// Death screen overlay (shown when HP reaches 0)
const deathOverlayEl = document.getElementById('death-menu-overlay');
const deathRestartBtn = document.getElementById('death-restart-btn');
if (deathRestartBtn) {
  deathRestartBtn.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    // Hard reset: reload page to reset all runtime state
    window.location.reload();
  });
}

// Bullets
const bullets = [];
let fireCooldown = 0;

// Asteroids (loaded from level)
let asteroids = [];
let structures = [];
let gameState.level.width = 10000;
let gameState.level.height = 10000;

// Floating items in space (dropped/jettisoned)
const floatingItems = [];

// Spark particles for laser impact
const particles = [];
let sparkCarry = 0; // fractional sparks accumulator (FPS independent)

function spawnSparks(x, y, count) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 50 + Math.random() * 150;
    const life = 0.2 + Math.random() * 0.3; // 0.2-0.5 seconds
    particles.push({
      x: x,
      y: y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life,
      maxLife: life,
      size: 1 + Math.random() * 2
    });
  }
}

// Drag state for hotbar (Legacy canvas drag removed)


const MAX_ORE_STACK = 10;
const ORE_ITEMS = ['cuprite', 'hematite', 'aurite', 'diamite', 'platinite', 'scrap']; // items that stack up to MAX_ORE_STACK

function getMaxStack(itemName) {
  return ORE_ITEMS.includes(itemName) ? MAX_ORE_STACK : 1;
}

// Add item to inventory (find matching stack or first empty slot)
function addToInventory(itemName, quantity) {
  const maxStack = getMaxStack(itemName);

  while (quantity > 0) {
    // First try to stack with existing item (up to maxStack)
    let added = false;
    for (let i = 0; i < hotbar.length && quantity > 0; i++) {
      if (hotbar[i] && hotbar[i].item === itemName && hotbar[i].quantity != null && hotbar[i].quantity < maxStack) {
        const space = maxStack - hotbar[i].quantity;
        const add = Math.min(quantity, space);
        hotbar[i].quantity += add;
        quantity -= add;
        added = true;
      }
    }
    if (quantity <= 0) return true;
    // Otherwise find first empty slot
    for (let i = 0; i < hotbar.length; i++) {
      if (!hotbar[i]) {
        const add = Math.min(quantity, maxStack);
        hotbar[i] = { item: itemName, quantity: add };
        quantity -= add;
        added = true;
        break;
      }
    }
    if (!added) return false; // Inventory full, quantity left is lost
  }
  return true;
}

// Starfield
const NUM_STARS = 2400;
const stars = [];

function initStars() {
  const spread = 5000;
  for (let i = 0; i < NUM_STARS; i++) {
    stars.push({
      x: (Math.random() - 0.5) * 2 * spread,
      y: (Math.random() - 0.5) * 2 * spread,
      size: Math.random() * 2 + 0.5,
      brightness: 0.3 + Math.random() * 0.7
    });
  }
}

function normalize(x, y) {
  const len = Math.sqrt(x * x + y * y);
  if (len === 0) return { x: 0, y: 0 };
  return { x: x / len, y: y / len };
}

function worldToScreen(wx, wy) {
  return {
    x: wx - ship.x + WIDTH / 2,
    y: wy - ship.y + HEIGHT / 2
  };
}

// Laser raycast: find closest asteroid hit by a ray from (ox, oy) in direction (dx, dy)
function laserHitAsteroid(ox, oy, dx, dy, maxLen) {
  let closest = null;
  let closestDist = maxLen;
  
  for (const ast of asteroids) {
    // Vector from ray origin to asteroid center
    const fx = ast.x - ox;
    const fy = ast.y - oy;
    
    // Project asteroid center onto ray
    const t = fx * dx + fy * dy;
    if (t < 0) continue; // Behind ray origin
    
    // Closest point on ray to asteroid center
    const cx = ox + dx * t;
    const cy = oy + dy * t;
    
    // Distance from closest point to asteroid center
    const distSq = (ast.x - cx) * (ast.x - cx) + (ast.y - cy) * (ast.y - cy);
    const radiusSq = ast.radius * ast.radius;
    
    if (distSq < radiusSq) {
      // Ray hits asteroid - calculate entry distance
      const offset = Math.sqrt(radiusSq - distSq);
      const hitDist = t - offset;
      
      if (hitDist > 0 && hitDist < closestDist) {
        closest = ast;
        closestDist = hitDist;
      }
    }
  }
  
  return closest ? { asteroid: closest, distance: closestDist } : null;
}

// Ray vs circle for pirate base (radius 54)
function laserHitPirateBase(ox, oy, dx, dy, maxLen) {
  let closest = null;
  let closestDist = maxLen;
  const radius = 54;
  const radiusSq = radius * radius;
  for (const st of structures) {
    if (st.type !== 'piratebase' || st.dead || st.health <= 0) continue;
    const fx = st.x - ox;
    const fy = st.y - oy;
    const t = fx * dx + fy * dy;
    if (t < 0) continue;
    const cx = ox + dx * t;
    const cy = oy + dy * t;
    const distSq = (st.x - cx) * (st.x - cx) + (st.y - cy) * (st.y - cy);
    if (distSq < radiusSq) {
      const offset = Math.sqrt(radiusSq - distSq);
      const hitDist = t - offset;
      if (hitDist > 0 && hitDist < closestDist) {
        closest = st;
        closestDist = hitDist;
      }
    }
  }
  return closest ? { structure: closest, distance: closestDist } : null;
}

const SHIP_SIZE = 10;
const SHIP_COLLISION_RADIUS = 8;
const SHIP_COLLECTION_RADIUS = 16;

const SHOT_SPREAD = 8;

function fireBullet() {
  const dx = inputManager.mouse.x - WIDTH / 2;
  const dy = inputManager.mouse.y - HEIGHT / 2;
  const dir = normalize(dx, dy);
  if (dir.x === 0 && dir.y === 0) return;
  const perp = { x: -dir.y, y: dir.x };
  const offsets = [-SHOT_SPREAD, 0, SHOT_SPREAD];
  for (const offset of offsets) {
    bullets.push({
      x: ship.x + dir.x * SHIP_SIZE + perp.x * offset,
      y: ship.y + dir.y * SHIP_SIZE + perp.y * offset,
      vx: dir.x * BULLET_SPEED + ship.vx,
      vy: dir.y * BULLET_SPEED + ship.vy,
      lifespan: 4,
      owner: 'player'
    });
  }
}

function fireBlasterPellet() {
  const dx = inputManager.mouse.x - WIDTH / 2;
  const dy = inputManager.mouse.y - HEIGHT / 2;
  const dir = normalize(dx, dy);
  if (dir.x === 0 && dir.y === 0) return;
  bullets.push({
    x: ship.x + dir.x * SHIP_SIZE,
    y: ship.y + dir.y * SHIP_SIZE,
    vx: dir.x * BULLET_SPEED + ship.vx,
    vy: dir.y * BULLET_SPEED + ship.vy,
    lifespan: 4,
    owner: 'player'
  });
}

// drawShip2D moved to Ship class

function drawCrosshairAndHeatBar() {
  if (!uiCtx) return;
  uiCtx.clearRect(0, 0, WIDTH, HEIGHT);
  if (gameState.ui.shopMenuOpen) return;
  const armLen = 6;
  const centerGap = 2;
  const crosshairX = Math.floor(inputManager.mouse.x) + 0.5;
  const crosshairY = Math.floor(inputManager.mouse.y) + 0.5;
  const armW = 2;
  uiCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
  uiCtx.fillRect(crosshairX - armW / 2, crosshairY - armLen, armW, armLen - centerGap);
  uiCtx.fillRect(crosshairX - armW / 2, crosshairY + centerGap, armW, armLen - centerGap);
  uiCtx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
  uiCtx.lineWidth = 1;
  uiCtx.lineCap = 'round';
  uiCtx.beginPath();
  uiCtx.moveTo(crosshairX - armLen, crosshairY);
  uiCtx.lineTo(crosshairX - centerGap, crosshairY);
  uiCtx.moveTo(crosshairX + centerGap, crosshairY);
  uiCtx.lineTo(crosshairX + armLen, crosshairY);
  uiCtx.stroke();
  const equipped = hotbar[gameState.selectedSlot];
  const hasHeatWeapon = equipped && equipped.heat != null && equipped.heat > 0 && (MINING_LASER_STATS[equipped.item] || equipped.item === 'light blaster');
  if (hasHeatWeapon) {
    const barW = 16;
    const barH = 4;
    const barY = inputManager.mouse.y + 8;
    const barX = inputManager.mouse.x - barW / 2;
    const isOverheated = equipped.overheated;
    uiCtx.fillStyle = isOverheated ? 'rgba(255, 0, 0, 0.2)' : 'rgba(255, 255, 255, 0.2)';
    uiCtx.fillRect(barX, barY, barW, barH);
    uiCtx.fillStyle = isOverheated ? 'rgba(255, 0, 0, 0.6)' : 'rgba(255, 255, 255, 0.6)';
    uiCtx.fillRect(barX, barY, barW * Math.min(1, equipped.heat), barH);
  }
}

function initShip3D() {
  if (typeof THREE === 'undefined') return;
  shipCanvas = document.getElementById('ship-canvas');
  if (!shipCanvas) return;
  const aspect = WIDTH / HEIGHT;
  shipCamera = new THREE.PerspectiveCamera(15, aspect, 1, 5000);
  shipCamera.position.set(0, 0, 3390);
  shipCamera.lookAt(0, 0, 0);
  shipScene = new THREE.Scene();
  asteroidContainer = new THREE.Group();
  shipScene.add(asteroidContainer);
  structureContainer = new THREE.Group();
  shipScene.add(structureContainer);
  pirateContainer = new THREE.Group();
  shipScene.add(pirateContainer);
  floatingOreContainer = new THREE.Group();
  shipScene.add(floatingOreContainer);
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(20, 20, 50);
  shipScene.add(light);
  const light2 = new THREE.DirectionalLight(0xffffff, 0.8);
  light2.position.set(-50, -30, 40);
  shipScene.add(light2);
  const topLight = new THREE.DirectionalLight(0xffffff, 3.0);
  topLight.position.set(0, 100, 20);
  shipScene.add(topLight);
  shipScene.add(new THREE.AmbientLight(0xffffff, 1.0));
  shipRenderer = new THREE.WebGLRenderer({ canvas: shipCanvas, antialias: true, alpha: true });
  shipRenderer.setPixelRatio(window.devicePixelRatio || 1);
  shipRenderer.setSize(WIDTH, HEIGHT);
  shipRenderer.setClearColor(0x000000, 0);
  const LoaderClass = (window.GLTFLoader || (THREE && THREE.GLTFLoader));
  if (!LoaderClass) return;
  const loader = new LoaderClass();
  const glbUrl = new URL('assets/scout-ship.glb', window.location.href).toString();
  loader.load(glbUrl, (gltf) => {
    const model = gltf.scene;
    const box = new THREE.Box3().setFromObject(model);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);
    const scale = (SHIP_SIZE * 2) / (maxDim > 0 ? maxDim : 1) * 1.2;
    model.scale.setScalar(scale);
    model.position.sub(center.multiplyScalar(scale));
    // Convert common glTF orientation (Y-up, Z-forward) into our top-down XY view.
    model.rotation.x = -Math.PI / 2;
    // Shift centerpoint up a bit for better visual alignment
    model.position.y += 3;
    shipMesh = model;
    shipScene.add(shipMesh);
    
    // Create thruster flames (two small cones at the back)
    const flameHeight = 0.42;
    const flameGeom = new THREE.ConeGeometry(0.105, flameHeight, 8);
    const flameMat = new THREE.MeshBasicMaterial({ color: 0xffcc44, transparent: true, opacity: 0.9 });
    const flame1 = new THREE.Mesh(flameGeom.clone(), flameMat.clone());
    const flame2 = new THREE.Mesh(flameGeom.clone(), flameMat.clone());
    flame1.rotation.x = -Math.PI / 2; // Point flames backward (horizontal)
    flame2.rotation.x = -Math.PI / 2;
    // Offset cone so base is at origin (for scaling from base)
    flame1.position.set(0, 0, -flameHeight / 2);
    flame2.position.set(0, 0, -flameHeight / 2);
    const flameGroup1 = new THREE.Group();
    const flameGroup2 = new THREE.Group();
    flameGroup1.add(flame1);
    flameGroup2.add(flame2);
    flameGroup1.position.set(-0.15, 0.3, -0.9);
    flameGroup2.position.set(0.15, 0.3, -0.9);
    flameGroup1.visible = false;
    flameGroup2.visible = false;
    shipMesh.add(flameGroup1);
    shipMesh.add(flameGroup2);
    shipFlames = [flameGroup1, flameGroup2];
    
    shipModelLoaded = true;
    // eslint-disable-next-line no-console
    console.log('[ship3d] Loaded scout-ship.glb');
  }, undefined, (err) => {
    // eslint-disable-next-line no-console
    console.error('[ship3d] Failed to load scout-ship.glb', err);
  });

  function setupAsteroidModel(model) {
    model.traverse((child) => {
      if (child.isMesh && child.material) {
        const oldMat = child.material;
        const newMat = new THREE.MeshStandardMaterial({
          color: oldMat.color ? oldMat.color.clone() : 0x888888,
          map: oldMat.map || null,
          roughness: 0.8,
          metalness: 0.2,
          emissive: 0x333333,
          emissiveMap: oldMat.map || null,
          emissiveIntensity: 50.0
        });
        child.material = newMat;
      }
    });
    const box = new THREE.Box3().setFromObject(model);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);
    const scale = 1 / (maxDim > 0 ? maxDim : 1);
    model.scale.setScalar(scale);
    model.position.sub(center.multiplyScalar(scale));
    model.rotation.x = -Math.PI / 2;
  }
  let asteroidsLoaded = 0;
  const TOTAL_ASTEROID_MODELS = 6;
  const SMALL_ASTEROID_FILES = ['small-asteroid1.glb', 'small-asteroid2.glb', 'small-asteroid3.glb'];
  const MEDIUM_ASTEROID_FILES = ['medium-asteroid1.glb', 'medium-asteroid2.glb'];
  function onAsteroidLoaded() {
    asteroidsLoaded++;
    if (asteroidsLoaded === TOTAL_ASTEROID_MODELS) refreshAsteroidMeshes();
  }
  SMALL_ASTEROID_FILES.forEach((filename, i) => {
    const url = new URL('assets/' + filename, window.location.href).toString();
    loader.load(url, (gltf) => {
      const model = gltf.scene;
      setupAsteroidModel(model);
      smallAsteroidModels[i] = model;
      onAsteroidLoaded();
      console.log('[ship3d] Loaded ' + filename);
    }, undefined, (err) => console.error('[ship3d] Failed to load ' + filename, err));
  });
  MEDIUM_ASTEROID_FILES.forEach((filename, i) => {
    const url = new URL('assets/' + filename, window.location.href).toString();
    loader.load(url, (gltf) => {
      const model = gltf.scene;
      setupAsteroidModel(model);
      mediumAsteroidModels[i] = model;
      onAsteroidLoaded();
      console.log('[ship3d] Loaded ' + filename);
    }, undefined, (err) => console.error('[ship3d] Failed to load ' + filename, err));
  });
  loader.load(new URL('assets/large-asteroid1.glb', window.location.href).toString(), (gltf) => {
    const model = gltf.scene;
    setupAsteroidModel(model);
    largeAsteroidModel = model;
    onAsteroidLoaded();
    console.log('[ship3d] Loaded large-asteroid1.glb');
  }, undefined, (err) => console.error('[ship3d] Failed to load large-asteroid1.glb', err));

  function setupStructureModel(model, structureType) {
    const isPirateBase = structureType === 'piratebase';
    model.traverse((child) => {
      if (child.isMesh && child.material) {
        const oldMat = child.material;
        const newMat = new THREE.MeshStandardMaterial({
          color: oldMat.color ? oldMat.color.clone() : 0x888888,
          map: oldMat.map || null,
          roughness: 0.8,
          metalness: 0.2,
          emissive: isPirateBase ? 0x882222 : 0x333333,
          emissiveMap: oldMat.map || null,
          emissiveIntensity: isPirateBase ? 0.08 : 50.0
        });
        child.material = newMat;
      }
    });
    const box = new THREE.Box3().setFromObject(model);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);
    const scale = 1 / (maxDim > 0 ? maxDim : 1);
    model.scale.setScalar(scale);
    model.position.sub(center.multiplyScalar(scale));
    model.rotation.x = Math.PI / 4; // 45Â°
    model.rotation.y = Math.PI / 4; // 45Â°
  }
  const STRUCTURE_FILES = [
    { type: 'warpgate', file: 'warp-gate.glb' },
    { type: 'shop', file: 'shop.glb' },
    { type: 'piratebase', file: 'pirate-base.glb' }
  ];
  STRUCTURE_FILES.forEach(({ type, file }) => {
    loader.load(new URL('assets/' + file, window.location.href).toString(), (gltf) => {
      const model = gltf.scene;
      setupStructureModel(model, type);
      structureModels[type] = model;
      console.log('[ship3d] Loaded ' + file);
      refreshStructureMeshes();
    }, undefined, (err) => console.error('[ship3d] Failed to load ' + file, err));
  });

  loader.load(new URL('assets/ore.glb', window.location.href).toString(), (gltf) => {
    const model = gltf.scene;
    const box = new THREE.Box3().setFromObject(model);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z) || 1;
    const scale = 1 / maxDim;
    model.scale.setScalar(scale);
    model.position.sub(center.multiplyScalar(scale));
    model.rotation.x = -Math.PI / 2;
    model.rotation.y = Math.PI; // flip 180
    oreModel = model;
    buildOreIconDataUrls();
    console.log('[ship3d] Loaded ore.glb');
  }, undefined, (err) => console.error('[ship3d] Failed to load ore.glb', err));

  loader.load(new URL('assets/scrap.glb', window.location.href).toString(), (gltf) => {
    const model = gltf.scene;
    const box = new THREE.Box3().setFromObject(model);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z) || 1;
    const scale = 1 / maxDim;
    model.scale.setScalar(scale);
    model.position.sub(center.multiplyScalar(scale));
    model.rotation.x = -Math.PI / 2;
    model.rotation.y = Math.PI; // flip 180
    scrapModel = model;
    buildScrapIconDataUrl();
    console.log('[ship3d] Loaded scrap.glb');
  }, undefined, (err) => console.error('[ship3d] Failed to load scrap.glb', err));

  loader.load(new URL('assets/pirate.glb', window.location.href).toString(), (gltf) => {
    const model = gltf.scene;
    const box = new THREE.Box3().setFromObject(model);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z) || 1;
    const scale = (SHIP_SIZE * 2) / maxDim * 1.1; 
    model.scale.setScalar(scale);
    model.position.sub(center.multiplyScalar(scale));
    // Convert common glTF orientation (Y-up, Z-forward) into our top-down XY view.
    model.rotation.x = -Math.PI / 2;
    model.rotation.y = Math.PI; // flip 180 if needed, we'll align with rotation
    
    // Apply reddish emissive material (texture map shapes glow like asteroids)
    model.traverse((child) => {
      if (child.isMesh && child.material) {
        const oldMat = child.material;
        const newMat = new THREE.MeshStandardMaterial({
          color: oldMat.color ? oldMat.color.clone() : 0xee9999,
          map: oldMat.map || null,
          roughness: 0.7,
          metalness: 0.3,
          emissive: 0xffffff,
          emissiveMap: oldMat.map || null,
          emissiveIntensity: 1.5
        });
        child.material = newMat;
      }
    });
    
    pirateModel = model;
    console.log('[ship3d] Loaded pirate.glb');
  }, undefined, (err) => console.error('[ship3d] Failed to load pirate.glb', err));
}

function buildOreIconDataUrls() {
  if (!oreModel || typeof THREE === 'undefined') return;
  const size = 64;
  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
  renderer.setSize(size, size);
  renderer.setClearColor(0x000000, 0);
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 10);
  camera.position.set(0, 0, 1.4);
  camera.lookAt(0, 0, 0);
  scene.add(new THREE.AmbientLight(0xffffff, 0.8));
  const dir = new THREE.DirectionalLight(0xffffff, 1.2);
  dir.position.set(0.5, 0.5, 1);
  scene.add(dir);
  for (const itemKey of FLOATING_ORE_ITEMS) {
    if (itemKey === 'scrap') continue;
    const clone = oreModel.clone(true);
    applyFloatingOreMaterial(clone, itemKey);
    clone.position.set(0, 0, 0);
    clone.rotation.x = -Math.PI / 2;
    clone.rotation.y = Math.PI;
    clone.rotation.z = 0;
    scene.add(clone);
    renderer.render(scene, camera);
    try {
      ORE_ICON_DATA_URLS[itemKey] = canvas.toDataURL('image/png');
    } catch (e) { /* security / CORS */ }
    scene.remove(clone);
  }
  renderer.dispose();
}

function buildScrapIconDataUrl() {
  if (!scrapModel || typeof THREE === 'undefined') return;
  const size = 64;
  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
  renderer.setSize(size, size);
  renderer.setClearColor(0x000000, 0);
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 10);
  camera.position.set(0, 0, 1.4);
  camera.lookAt(0, 0, 0);
  scene.add(new THREE.AmbientLight(0xffffff, 0.8));
  const dir = new THREE.DirectionalLight(0xffffff, 1.2);
  dir.position.set(0.5, 0.5, 1);
  scene.add(dir);
  const clone = scrapModel.clone(true);
  applyFloatingOreMaterial(clone, 'scrap');
  clone.position.set(0, 0, 0);
  clone.rotation.x = -Math.PI / 2;
  clone.rotation.y = Math.PI;
  clone.rotation.z = 0;
  scene.add(clone);
  renderer.render(scene, camera);
  try {
    ORE_ICON_DATA_URLS['scrap'] = canvas.toDataURL('image/png');
  } catch (e) { /* security / CORS */ }
  renderer.dispose();
}

function refreshAsteroidMeshes() {
  const smallLoaded = smallAsteroidModels.every(m => m != null);
  const mediumLoaded = mediumAsteroidModels.every(m => m != null);
  if (!asteroidContainer || !smallLoaded || !mediumLoaded || !largeAsteroidModel) return;
  while (asteroidContainer.children.length) asteroidContainer.remove(asteroidContainer.children[0]);
  const rng = createSeededRandom(gameState.level.seed);
  for (const ast of asteroids) {
    ast._mesh = null;
    let src = null;
    if (ast.radius >= 10 && ast.radius <= 30) {
      const modelIndex = Math.floor(rng() * 3);
      src = smallAsteroidModels[modelIndex];
    } else if (ast.radius >= 40 && ast.radius <= 90) {
      const modelIndex = rng() < 0.8 ? 0 : 1; // 80% medium-asteroid1, 20% medium-asteroid2
      src = mediumAsteroidModels[modelIndex];
    } else if (ast.radius >= 100) {
      src = largeAsteroidModel;
    }
    if (!src) continue;
    ast._initialSpinPhase = rng() * Math.PI * 2;
    const spinAxis = Math.floor(rng() * 3);
    const spinDirection = rng() < 0.5 ? -1 : 1;
    ast._spinSpeed = 0.3 * (0.7 + rng() * 0.6) * (ast.radius >= 100 ? 0.7 : 1);
    ast._spinAxis = spinAxis;
    ast._spinDirection = spinDirection;
    const clone = src.clone(true);
    if (ast.oreType && ast.oreType !== 'cuprite') applyOreEmissiveMaterial(clone, ast.oreType);
    // Compute scale from unrotated model so same radius => same visual size (hitbox match)
    const box = new THREE.Box3().setFromObject(clone);
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z) || 1;
    const sizeMult = 1.05;
    const scale = ((ast.radius * 2) / maxDim) * sizeMult;
    clone.scale.setScalar(scale);
    clone.rotation[['x', 'y', 'z'][spinAxis]] = ast._initialSpinPhase;
    ast._mesh = clone;
    asteroidContainer.add(clone);
  }
}

// Non-cuprite asteroids: emissive glow in ore color, intensity 0.06
const ORE_EMISSIVE_COLOR = { hematite: 0xA0522D, aurite: 0xFFD700, diamite: 0x909090, platinite: 0xE5E4E2 };
const ORE_EMISSIVE_INTENSITY = { hematite: 0.06, aurite: 0.02, diamite: 0.06, platinite: 0.06 };
function applyOreEmissiveMaterial(mesh, oreType) {
  const emissiveColor = ORE_EMISSIVE_COLOR[oreType] ?? 0x888888;
  const intensity = ORE_EMISSIVE_INTENSITY[oreType] ?? 0.06;
  mesh.traverse((child) => {
    if (child.isMesh && child.material) {
      const oldMat = child.material;
      child.material = new THREE.MeshStandardMaterial({
        color: oldMat.color ? oldMat.color.clone() : 0x888888,
        map: oldMat.map || null,
        roughness: oldMat.roughness ?? 0.8,
        metalness: oldMat.metalness ?? 0.2,
        emissive: emissiveColor,
        emissiveIntensity: intensity
      });
    }
  });
}

// Floating ore drops: self-lit like asteroids with ore-colored emissive tint
const FLOATING_ORE_ITEMS = ['cuprite', 'hematite', 'aurite', 'diamite', 'platinite', 'scrap', 'warp key'];
const FLOATING_ORE_EMISSIVE = { cuprite: 0x7A6D5F, hematite: 0x804224, aurite: 0xCCAC00, diamite: 0x737373, platinite: 0xB7B6B5, scrap: 0x888888, 'warp key': 0xAE841A };
const ORE_ICON_DATA_URLS = {}; // itemKey -> data URL for inventory slot (3D ore, no rotation)

function applyFloatingOreMaterial(mesh, itemKey) {
  const emissiveColor = FLOATING_ORE_EMISSIVE[itemKey] ?? 0x888888;
  mesh.traverse((child) => {
    if (child.isMesh && child.material) {
      const oldMat = child.material;
      child.material = new THREE.MeshStandardMaterial({
        color: oldMat.color ? oldMat.color.clone() : 0x888888,
        map: oldMat.map || null,
        roughness: oldMat.roughness ?? 0.8,
        metalness: oldMat.metalness ?? 0.2,
        emissive: emissiveColor,
        emissiveMap: oldMat.map || null,
        emissiveIntensity: 5.0
      });
    }
  });
}

function refreshStructureMeshes() {
  if (!structureContainer) return;
  const STRUCTURE_SIZE = 40;
  const STRUCTURE_DIAMETER = STRUCTURE_SIZE * 2;
  const STRUCTURE_SCALE_MULT = 2.7; // base
  const scaleMultByType = { warpgate: 1.15, shop: 1.10, piratebase: 1.0, crafting: 1.0, shipyard: 1.2 };
  while (structureContainer.children.length) structureContainer.remove(structureContainer.children[0]);
  for (const st of structures) {
    if (st.type !== 'warpgate' && st.type !== 'shop' && st.type !== 'piratebase' && st.type !== 'crafting' && st.type !== 'shipyard') continue;
    if (st.type === 'piratebase' && (st.dead || st.health <= 0)) continue;
    const src = structureModels[st.type] || structureModels['shop']; // Fallback to shop model
    if (!src) continue;
    const clone = src.clone(true);
    const box = new THREE.Box3().setFromObject(clone);
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z) || 1;
    const typeMult = scaleMultByType[st.type] ?? 1.0;
    const scale = (STRUCTURE_DIAMETER / maxDim) * STRUCTURE_SCALE_MULT * typeMult;
    clone.scale.setScalar(scale);
    st._mesh = clone;
    structureContainer.add(clone);
  }
}

function spawnPirateGroup(minCount, maxCount) {
  const count = minCount + Math.floor(Math.random() * (maxCount - minCount + 1));
  const angle = Math.random() * Math.PI * 2;
  const dist = 1100; // Just outside view
  const cx = ship.x + Math.cos(angle) * dist;
  const cy = ship.y + Math.sin(angle) * dist;

  const spreadRadius = 50;
  for (let i = 0; i < count; i++) {
    const r = Math.random() * spreadRadius;
    const a = Math.random() * Math.PI * 2;
    pirates.push({
      x: cx + Math.cos(a) * r,
      y: cy + Math.sin(a) * r,
      vx: 0,
      vy: 0,
      health: PIRATE_HEALTH,
      maxHealth: PIRATE_HEALTH,
      state: 'chase',
      stateTimer: Math.random() * 5,
      cooldown: 1 + Math.random() * 2,
      id: Math.random(),
      facingAngle: angle, // Face toward player initially
      prevFacingAngle: angle,
      tilt: 0
    });
  }
}

const BASE_DEFENSE_ORBIT_RADIUS = 100;
const BASE_DEFENSE_ORBIT_SPEED = 0.3;

function spawnBaseDefensePirates(st) {
  const count = st.defenseCount !== undefined ? st.defenseCount : 8;
  for (let i = 0; i < count; i++) {
    const orbitAngle = (i / count) * Math.PI * 2;
    pirates.push({
      x: st.x + Math.cos(orbitAngle) * BASE_DEFENSE_ORBIT_RADIUS,
      y: st.y + Math.sin(orbitAngle) * BASE_DEFENSE_ORBIT_RADIUS,
      vx: 0,
      vy: 0,
      health: PIRATE_HEALTH,
      maxHealth: PIRATE_HEALTH,
      state: 'chase',
      stateTimer: Math.random() * 5,
      cooldown: 1 + Math.random() * 2,
      id: Math.random(),
      facingAngle: orbitAngle + Math.PI / 2,
      prevFacingAngle: orbitAngle + Math.PI / 2,
      tilt: 0,
      defendingBase: st,
      orbitAngle,
      orbitRadius: BASE_DEFENSE_ORBIT_RADIUS
    });
  }
}

const PIRATE_BASE_AGGRO_RADIUS = 300;
const PIRATE_BASE_HIT_RADIUS = 54;

function onPirateBaseDeath(st) {
  if (st.dead) return;
  st.dead = true;
  
  const drops = st.drops || [
    { item: 'scrap', quantity: 50 },
    { item: 'warp key', quantity: 1 }
  ];

  for (const drop of drops) {
    for (let k = 0; k < drop.quantity; k++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 20 + Math.random() * 40;
      floatingItems.push({
        x: st.x,
        y: st.y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        item: drop.item,
        quantity: 1
      });
    }
  }

  if (st._mesh && structureContainer) structureContainer.remove(st._mesh);
  st._mesh = null;
}

function updatePirates(dt) {
  // Aggro: player entering radius 300 around any living pirate base
  for (const st of structures) {
    if (st.type !== 'piratebase' || st.dead || st.health <= 0) continue;
    const d = Math.sqrt((ship.x - st.x) ** 2 + (ship.y - st.y) ** 2);
    if (d < PIRATE_BASE_AGGRO_RADIUS) st.aggroed = true;
  }

  // Spawning logic using level settings
  // Spawn based on absolute schedule (no countdown reset between tiers/phases).
  if (gameState.level.isDebug) {
    while (gameState.level.elapsedTime >= gameState.level.pirateNextWaveTime) {
      spawnPirateGroup(6, 10);
      gameState.level.pirateNextWaveTime += 5;
    }
  } else {
    while (gameState.level.elapsedTime >= gameState.level.pirateNextWaveTime) {
      const t = gameState.level.pirateNextWaveTime;

      // Determine active tier based on the scheduled spawn time.
      let activeTier = null;
      if (gameState.level.spawnSettings.tiers && gameState.level.spawnSettings.tiers.length > 0) {
        // Find the tier with the highest startTime that is <= current time
        // Tiers should be sorted by startTime, but we'll iterate to be safe
        let bestStart = -1;
        for (const tier of gameState.level.spawnSettings.tiers) {
          if (t >= tier.startTime && tier.startTime > bestStart) {
            bestStart = tier.startTime;
            activeTier = tier;
          }
        }
      }

      // Use active tier settings or fall back to base settings
      const minWave = activeTier ? activeTier.waveSizeMin : gameState.level.spawnSettings.waveSizeMin;
      const maxWave = activeTier ? activeTier.waveSizeMax : gameState.level.spawnSettings.waveSizeMax;
      const minInt = activeTier ? activeTier.waveIntervalMin : gameState.level.spawnSettings.waveIntervalMin;
      const maxInt = activeTier ? activeTier.waveIntervalMax : gameState.level.spawnSettings.waveIntervalMax;

      spawnPirateGroup(minWave, maxWave);

      // Schedule next wave (keep time moving forward even if dt is large)
      const rawInterval = minInt + Math.random() * (maxInt - minInt);
      const interval = Math.max(0.1, rawInterval);
      gameState.level.pirateNextWaveTime += interval;
    }
  }

  const STRUCTURE_SIZE_COLL = 54;
  for (let i = pirates.length - 1; i >= 0; i--) {
    const p = pirates[i];
    let inDefenseMode = false;
    if (p.defendingBase) {
      const base = p.defendingBase;
      if (base.health <= 0 || base.dead || base.aggroed) {
        // treat as normal pirate
      } else {
        inDefenseMode = true;
        p.orbitAngle += dt * BASE_DEFENSE_ORBIT_SPEED;
        p.x = base.x + Math.cos(p.orbitAngle) * (p.orbitRadius || BASE_DEFENSE_ORBIT_RADIUS);
        p.y = base.y + Math.sin(p.orbitAngle) * (p.orbitRadius || BASE_DEFENSE_ORBIT_RADIUS);
        p.vx = 0;
        p.vy = 0;
        p.facingAngle = p.orbitAngle + Math.PI / 2;
      }
    }

    const dx = ship.x - p.x;
    const dy = ship.y - p.y;
    const distToPlayer = Math.sqrt(dx*dx + dy*dy);
    const dirToPlayer = distToPlayer > 0 ? {x: dx/distToPlayer, y: dy/distToPlayer} : {x:0, y:0};

    if (!inDefenseMode) {
      // AI Target / Behavior
      p.stateTimer -= dt;
      if (p.stateTimer <= 0) {
         p.state = Math.random() < 0.6 ? 'chase' : 'circle';
         p.stateTimer = 2 + Math.random() * 4;
      }

      let ax = 0;
      let ay = 0;
      if (p.state === 'chase') {
          ax += dirToPlayer.x * PIRATE_ACCEL;
          ay += dirToPlayer.y * PIRATE_ACCEL;
      } else {
          const cw = (p.id > 0.5) ? 1 : -1;
          ax += -dirToPlayer.y * cw * PIRATE_ACCEL;
          ay += dirToPlayer.x * cw * PIRATE_ACCEL;
      }

      const lookAhead = 150;
      const lookAheadObstacle = 50;
      for (const ast of asteroids) {
          const adx = ast.x - p.x;
          const ady = ast.y - p.y;
          const adist = Math.sqrt(adx*adx + ady*ady);
          if (adist < ast.radius + lookAheadObstacle) {
              ax -= (adx / adist) * 400;
              ay -= (ady / adist) * 400;
          }
      }
      for (const st of structures) {
         if (st.type !== 'warpgate' && st.type !== 'shop' && st.type !== 'piratebase' && st.type !== 'crafting' && st.type !== 'shipyard') continue;
         if (st.type === 'piratebase' && (st.dead || st.health <= 0)) continue;
         const sdx = st.x - p.x;
         const sdy = st.y - p.y;
         const sdist = Math.sqrt(sdx*sdx + sdy*sdy);
         if (sdist < STRUCTURE_SIZE_COLL + lookAheadObstacle) {
             ax -= (sdx / sdist) * 400;
             ay -= (sdy / sdist) * 400;
         }
      }
      const PLAYER_AVOID_RADIUS = 5;
      const pdx = ship.x - p.x;
      const pdy = ship.y - p.y;
      const pdist = Math.sqrt(pdx*pdx + pdy*pdy);
      if (pdist > 0 && pdist < PLAYER_AVOID_RADIUS + lookAhead) {
          ax -= (pdx / pdist) * 400;
          ay -= (pdy / pdist) * 400;
      }
      for (const other of pirates) {
          if (other === p) continue;
          const odx = other.x - p.x;
          const ody = other.y - p.y;
          const odist = Math.sqrt(odx*odx + ody*ody);
          if (odist < 40) {
              ax -= (odx / odist) * 200;
              ay -= (ody / odist) * 200;
          }
      }

      p.vx += ax * dt;
      p.vy += ay * dt;

      const thrustMag = Math.sqrt(ax * ax + ay * ay);
      if (thrustMag > 10) {
        const targetAngle = Math.atan2(ay, ax);
        let angleDiff = targetAngle - p.facingAngle;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
        p.facingAngle += angleDiff * Math.min(1, 3 * dt);
      }

      p.vx *= Math.max(0, 1 - PIRATE_FRICTION * dt);
      p.vy *= Math.max(0, 1 - PIRATE_FRICTION * dt);

      const speed = Math.sqrt(p.vx*p.vx + p.vy*p.vy);
      if (speed > PIRATE_MAX_SPEED) {
          const scale = PIRATE_MAX_SPEED / speed;
          p.vx *= scale;
          p.vy *= scale;
      }

      p.x += p.vx * dt;
      p.y += p.vy * dt;
    }

    // Physics Collisions (Bounce) â€“ pirates do not damage asteroids
    // Asteroids
    for (const ast of asteroids) {
        const cdx = p.x - ast.x;
        const cdy = p.y - ast.y;
        const cdist = Math.sqrt(cdx*cdx + cdy*cdy);
        const minDist = SHIP_COLLISION_RADIUS + ast.radius;
        if (cdist < minDist) {
            const nx = cdx/cdist;
            const ny = cdy/cdist;
            const overlap = minDist - cdist;
            p.x += nx * overlap;
            p.y += ny * overlap;
            const impact = p.vx * nx + p.vy * ny;
            if (impact < 0) {
                p.vx -= 1.3 * impact * nx;
                p.vy -= 1.3 * impact * ny;
            }
        }
    }
    // Structures
    for (const st of structures) {
        if (st.type !== 'warpgate' && st.type !== 'shop' && st.type !== 'piratebase' && st.type !== 'crafting' && st.type !== 'shipyard') continue;
        if (st.type === 'piratebase' && (st.dead || st.health <= 0)) continue;
        const cdx = p.x - st.x;
        const cdy = p.y - st.y;
        const cdist = Math.sqrt(cdx*cdx + cdy*cdy);
        const minDist = SHIP_COLLISION_RADIUS + STRUCTURE_SIZE_COLL;
        if (cdist < minDist) {
            const nx = cdx/cdist;
            const ny = cdy/cdist;
            const overlap = minDist - cdist;
            p.x += nx * overlap;
            p.y += ny * overlap;
            const impact = p.vx * nx + p.vy * ny;
            if (impact < 0) {
                p.vx -= 1.3 * impact * nx;
                p.vy -= 1.3 * impact * ny;
            }
        }
    }

    // Firing (defense-mode pirates do not shoot)
    if (!inDefenseMode) {
    p.cooldown -= dt;
    if (p.cooldown <= 0 && distToPlayer < 700) {
         p.cooldown = 1.0 + Math.random() * 2.0;
         
         // Anticipate: use pirate bullet speed so lead matches travel time
         const timeToHit = distToPlayer / PIRATE_BULLET_SPEED;
         const predX = ship.x + ship.vx * timeToHit;
         const predY = ship.y + ship.vy * timeToHit;
         
         const aimX = predX + (Math.random()-0.5) * 60;
         const aimY = predY + (Math.random()-0.5) * 60;
         
         const fdx = aimX - p.x;
         const fdy = aimY - p.y;
         const fdist = Math.sqrt(fdx*fdx + fdy*fdy);
         const fdir = (fdist > 0) ? {x: fdx/fdist, y: fdy/fdist} : {x:1, y:0};
         
         bullets.push({
             x: p.x + fdir.x * SHIP_SIZE,
             y: p.y + fdir.y * SHIP_SIZE,
             vx: fdir.x * PIRATE_BULLET_SPEED + p.vx,
             vy: fdir.y * PIRATE_BULLET_SPEED + p.vy,
             lifespan: 4,
             owner: 'pirate'
         });
    }
    }

    // Update tilt (bank when turning)
    let deltaAngle = p.facingAngle - (p.prevFacingAngle !== undefined ? p.prevFacingAngle : p.facingAngle);
    while (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
    while (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
    p.prevFacingAngle = p.facingAngle;
    
    const TILT_SENSITIVITY = 8;
    const TILT_DECAY = 4;
    p.tilt = (p.tilt || 0) + deltaAngle * TILT_SENSITIVITY - (p.tilt || 0) * TILT_DECAY * dt;
    p.tilt = Math.max(-0.5, Math.min(0.5, p.tilt));

    // Death: drop 3-5 scrap only if not fromBaseSpawn
    if (p.health <= 0) {
        spawnSparks(p.x, p.y, 15);
        if (!p.fromBaseSpawn) {
          const scrapCount = 3 + Math.floor(Math.random() * 3);
          for (let k = 0; k < scrapCount; k++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 20 + Math.random() * 40;
            floatingItems.push({
              x: p.x,
              y: p.y,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              item: 'scrap',
              quantity: 1
            });
          }
        }
        if (p._mesh && pirateContainer) pirateContainer.remove(p._mesh);
        pirates.splice(i, 1);
    }
  }
}

function update(dt) {
  gameState.level.elapsedTime += dt;
  ship.update(dt, inputManager);
  if (ship.isThrusting) gameState.ui.gameState.ui.tutorialTextTimerStarted = true;
  // Physics handled in ship.update

  // Shipâ€“asteroid collision: bounce and damage from perpendicular impact speed
  const BOUNCE_RESTITUTION = 0.3;
  const MAX_COLLISION_DAMAGE = 20;
  const DAMAGE_PER_SPEED = 0.1; // 200 units/sec impact => 20 damage
  for (const ast of asteroids) {
    const dx = ship.x - ast.x;
    const dy = ship.y - ast.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const minDist = SHIP_COLLISION_RADIUS + ast.radius;
    if (dist < minDist && dist > 0) {
      const nx = dx / dist;
      const ny = dy / dist;
      // Push ship out of overlap
      const overlap = minDist - dist;
      ship.x += nx * overlap;
      ship.y += ny * overlap;
      // Perpendicular impact speed (into asteroid is negative)
      const normalSpeed = ship.vx * nx + ship.vy * ny;
      if (normalSpeed < 0) {
        // Ship is moving into asteroid
        const impactSpeed = -normalSpeed; // positive value
        // Bounce: cancel inward velocity and add small outward push
        const bounce = impactSpeed * (1 + BOUNCE_RESTITUTION);
        ship.vx += nx * bounce;
        ship.vy += ny * bounce;
        // Damage from impact speed, max 20
        const damage = Math.min(MAX_COLLISION_DAMAGE, impactSpeed * DAMAGE_PER_SPEED);
        player.health = Math.max(0, player.health - damage);
        // Asteroid takes half the damage the player takes
        const currentHealth = ast.health ?? ast.radius;
        ast.health = Math.max(0, currentHealth - damage / 2);
        const impactX = ship.x * 0.9 + ast.x * 0.1;
        const impactY = ship.y * 0.9 + ast.y * 0.1;
        spawnSparks(impactX, impactY, Math.max(2, Math.round(damage)));
      }
    }
  }

  // Shipâ€“warp gate and shop collision (radius 35% bigger than base 40)
  const STRUCTURE_SIZE_COLL = 54;
  for (const st of structures) {
    if (st.type !== 'warpgate' && st.type !== 'shop' && st.type !== 'piratebase' && st.type !== 'crafting' && st.type !== 'shipyard') continue;
    if (st.type === 'piratebase' && (st.dead || st.health <= 0)) continue;
    const dx = ship.x - st.x;
    const dy = ship.y - st.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const minDist = SHIP_COLLISION_RADIUS + STRUCTURE_SIZE_COLL;
    if (dist < minDist && dist > 0) {
      const nx = dx / dist;
      const ny = dy / dist;
      const overlap = minDist - dist;
      ship.x += nx * overlap;
      ship.y += ny * overlap;
      const normalSpeed = ship.vx * nx + ship.vy * ny;
      if (normalSpeed < 0) {
        const impactSpeed = -normalSpeed;
        const bounce = impactSpeed * (1 + BOUNCE_RESTITUTION);
        ship.vx += nx * bounce;
        ship.vy += ny * bounce;
        const damage = Math.min(MAX_COLLISION_DAMAGE, impactSpeed * DAMAGE_PER_SPEED);
        player.health = Math.max(0, player.health - damage);
        const impactX = ship.x * 0.9 + st.x * 0.1;
        const impactY = ship.y * 0.9 + st.y * 0.1;
        spawnSparks(impactX, impactY, Math.max(2, Math.round(damage)));
        // Pirate base takes half the damage the player takes (same as asteroids)
        if (st.type === 'piratebase') {
          st.aggroed = true;
          const currentHealth = st.health ?? 100;
          st.health = Math.max(0, currentHealth - damage / 2);
          if (st.health <= 0) onPirateBaseDeath(st);
        }
      }
    }
  }

  // Oxygen depletion
  player.oxygen = Math.max(0, player.oxygen - OXYGEN_DEPLETION_RATE * dt);
  
  // No oxygen: drain health at 1 per second
  if (player.oxygen <= 0) {
    player.health = Math.max(0, player.health - 1 * dt);
  }

  // Mining lasers (light + medium): unified logic via MINING_LASER_STATS
  const hasEnergy = getFirstChargedCell() != null;
  const selectedItem = hotbar[gameState.selectedSlot];
  const miningLaser = selectedItem && MINING_LASER_STATS[selectedItem.item] ? selectedItem : null;
  const laserStats = miningLaser ? MINING_LASER_STATS[miningLaser.item] : null;

  if (miningLaser && laserStats && miningLaser.heat != null) {
    if (miningLaser.heat >= 1) miningLaser.overheated = true;
    if (miningLaser.heat <= 0) miningLaser.overheated = false;

    const canFire = !miningLaser.overheated;
    if (miningLaser && inputManager.mouse.left && hasEnergy && canFire) {
      miningLaser.heat = Math.min(1, miningLaser.heat + laserStats.heatRate * dt);
      const cell = getFirstChargedCell();
      if (cell) cell.energy = Math.max(0, cell.energy - laserStats.energyDrain * dt);

      const dx = inputManager.mouse.x - WIDTH / 2;
      const dy = inputManager.mouse.y - HEIGHT / 2;
      const dir = normalize(dx, dy);
      if (dir.x !== 0 || dir.y !== 0) {
        // Cap laser at screen edge (world units; 1:1 with screen pixels, ship at center)
        let maxLaserDist = 1500;
        if (Math.abs(dir.x) > 1e-6) maxLaserDist = Math.min(maxLaserDist, (WIDTH / 2) / Math.abs(dir.x));
        if (Math.abs(dir.y) > 1e-6) maxLaserDist = Math.min(maxLaserDist, (HEIGHT / 2) / Math.abs(dir.y));

        const hit = laserHitAsteroid(ship.x, ship.y, dir.x, dir.y, maxLaserDist);
        
        // Check Pirates for laser hit
        let hitPirate = null;
        let pirateDist = maxLaserDist;
        for (const p of pirates) {
             const fx = p.x - ship.x;
             const fy = p.y - ship.y;
             const t = fx * dir.x + fy * dir.y;
             if (t < 0) continue;
             const cx = ship.x + dir.x * t;
             const cy = ship.y + dir.y * t;
             const distSq = (p.x - cx)*(p.x - cx) + (p.y - cy)*(p.y - cy);
             const r = SHIP_COLLISION_RADIUS + 4;
             if (distSq < r*r) {
                 const offset = Math.sqrt(r*r - distSq);
                 const tHit = t - offset;
                 if (tHit > 0 && tHit < pirateDist) {
                     pirateDist = tHit;
                     hitPirate = p;
                 }
             }
        }

        const hitBase = laserHitPirateBase(ship.x, ship.y, dir.x, dir.y, maxLaserDist);
        const baseDist = hitBase ? hitBase.distance : maxLaserDist;

        let target = null;
        let hitDist = maxLaserDist;
        if (hit && hitPirate && hitBase) {
            if (hit.distance <= pirateDist && hit.distance <= baseDist) {
                target = hit.asteroid;
                hitDist = hit.distance;
            } else if (pirateDist <= baseDist) {
                target = hitPirate;
                hitDist = pirateDist;
            } else {
                target = hitBase.structure;
                hitDist = baseDist;
            }
        } else if (hit && hitPirate) {
            if (hit.distance < pirateDist) {
                target = hit.asteroid;
                hitDist = hit.distance;
            } else {
                target = hitPirate;
                hitDist = pirateDist;
            }
        } else if (hit && hitBase) {
            if (hit.distance < baseDist) {
                target = hit.asteroid;
                hitDist = hit.distance;
            } else {
                target = hitBase.structure;
                hitDist = baseDist;
            }
        } else if (hitPirate && hitBase) {
            if (pirateDist < baseDist) {
                target = hitPirate;
                hitDist = pirateDist;
            } else {
                target = hitBase.structure;
                hitDist = baseDist;
            }
        } else if (hit) {
            target = hit.asteroid;
            hitDist = hit.distance;
        } else if (hitPirate) {
            target = hitPirate;
            hitDist = pirateDist;
        } else if (hitBase) {
            target = hitBase.structure;
            hitDist = baseDist;
        }

        if (target) {
          target.health -= laserStats.dps * dt;
          if (target.defendingBase) target.defendingBase.aggroed = true;
          if (target.type === 'piratebase') {
            target.aggroed = true;
            if (target.health <= 0) onPirateBaseDeath(target);
          }
          const hitX = ship.x + dir.x * hitDist;
          const hitY = ship.y + dir.y * hitDist;
          sparkCarry += 60 * dt;
          const n = Math.floor(sparkCarry);
          if (n > 0) {
            spawnSparks(hitX, hitY, n);
            sparkCarry -= n;
          }
        }
      }
    } else {
      miningLaser.heat = Math.max(0, miningLaser.heat - laserStats.coolRate * dt);
    }
  }

  // Light blaster: 5 pellets/sec, 0.5 energy per pellet, 0.09 heat per pellet, cool 1/3 per sec
  const blaster = hotbar[gameState.selectedSlot] && hotbar[gameState.selectedSlot].item === 'light blaster' ? hotbar[gameState.selectedSlot] : null;
  if (blaster && blaster.heat != null) {
    if (blaster.heat >= 1) blaster.overheated = true;
    if (blaster.heat <= 0) blaster.overheated = false;
    const blasterCanFire = !blaster.overheated;
    const hasBlasterEnergy = getFirstCellWithMinEnergy(BLASTER_ENERGY_PER_SHOT) != null;
    if (blasterCanFire && inputManager.mouse.left && hasBlasterEnergy) {
      blasterFireAccum += BLASTER_FIRE_RATE * dt;
      while (blasterFireAccum >= 1) {
        blasterFireAccum -= 1;
        const c = getFirstCellWithMinEnergy(BLASTER_ENERGY_PER_SHOT);
        if (!c) break;
        c.energy = Math.max(0, c.energy - BLASTER_ENERGY_PER_SHOT);
        blaster.heat = Math.min(1, blaster.heat + BLASTER_HEAT_PER_SHOT);
        fireBlasterPellet();
      }
    } else {
      blaster.heat = Math.max(0, blaster.heat - BLASTER_COOL_RATE * dt);
    }
  }

  updatePirates(dt);

  // Pirate base: spawn 4 pirates every 30s when aggroed (orthogonal directions)
  const BASE_SPAWN_OFFSET = 80;
  for (const st of structures) {
    if (st.type !== 'piratebase' || st.dead || st.health <= 0 || !st.aggroed) continue;
    st.spawnTimer -= dt;
    if (st.spawnTimer <= 0) {
      st.spawnTimer = st.spawnRate || 30; // Use instance spawn rate
      const offsets = [
        [BASE_SPAWN_OFFSET, 0],
        [-BASE_SPAWN_OFFSET, 0],
        [0, BASE_SPAWN_OFFSET],
        [0, -BASE_SPAWN_OFFSET]
      ];
      for (const [ox, oy] of offsets) {
        const angle = Math.atan2(ship.y - (st.y + oy), ship.x - (st.x + ox));
        pirates.push({
          x: st.x + ox,
          y: st.y + oy,
          vx: 0,
          vy: 0,
          health: PIRATE_HEALTH,
          maxHealth: PIRATE_HEALTH,
          state: 'chase',
          stateTimer: Math.random() * 5,
          cooldown: 1 + Math.random() * 2,
          id: Math.random(),
          facingAngle: angle,
          prevFacingAngle: angle,
          tilt: 0,
          fromBaseSpawn: true
        });
      }
    }
  }

  // Bullets (movement + bullet-asteroid collision)
  const BULLET_DAMAGE = 4;            // pirate bullet damage to player
  const BULLET_DAMAGE_PIRATE = 3;    // light blaster damage per pellet to pirates
  const BULLET_DAMAGE_ASTEROID = 0.25; // pellets deal only 0.25 to asteroids
  const VIEWPORT_HALF_W = WIDTH / 2;
  const VIEWPORT_HALF_H = HEIGHT / 2;
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    b.lifespan -= dt;
    let remove = b.lifespan <= 0;
    if (!remove) {
      const screenX = b.x - ship.x + VIEWPORT_HALF_W;
      const screenY = b.y - ship.y + VIEWPORT_HALF_H;
      if (screenX < 0 || screenX > WIDTH || screenY < 0 || screenY > HEIGHT) remove = true;
    }
    if (!remove) {
      // Check Asteroids (bullet stops on hit; only player bullets damage)
      for (const ast of asteroids) {
        const dx = b.x - ast.x;
        const dy = b.y - ast.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < ast.radius) {
          if (b.owner === 'player') ast.health -= BULLET_DAMAGE_ASTEROID;
          remove = true;
          break;
        }
      }

      // Check Pirate Base (player bullets only)
      if (!remove && b.owner === 'player') {
        for (const st of structures) {
          if (st.type !== 'piratebase' || st.dead || st.health <= 0) continue;
          const dx = b.x - st.x;
          const dy = b.y - st.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < PIRATE_BASE_HIT_RADIUS) {
            st.health -= BULLET_DAMAGE_PIRATE;
            st.aggroed = true;
            remove = true;
            spawnSparks(b.x, b.y, 4);
            if (st.health <= 0) onPirateBaseDeath(st);
            break;
          }
        }
      }

      // Check Pirates (Player bullets)
      if (!remove && b.owner === 'player') {
        for (const p of pirates) {
            const dx = b.x - p.x;
            const dy = b.y - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < SHIP_COLLISION_RADIUS + 4) {
                p.health -= BULLET_DAMAGE_PIRATE;
                if (p.defendingBase) p.defendingBase.aggroed = true;
                remove = true;
                spawnSparks(b.x, b.y, 2);
                break;
            }
        }
      }
      
      // Check Player (Pirate bullets)
      if (!remove && b.owner === 'pirate') {
          const dx = b.x - ship.x;
          const dy = b.y - ship.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < SHIP_COLLISION_RADIUS) {
              player.health = Math.max(0, player.health - BULLET_DAMAGE);
              remove = true;
              spawnSparks(b.x, b.y, 4);
          }
      }
    }
    if (remove) bullets.splice(i, 1);
  }

  // Particles (sparks)
  const PARTICLE_DRAG = 6; // per-second velocity decay
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    const damp = Math.exp(-PARTICLE_DRAG * dt);
    p.vx *= damp;
    p.vy *= damp;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Check for destroyed asteroids and drop ore (diminishing returns: +10 at tier 1, then decreases by 1 every 2 tiers, min +4)
  function calculateOreCount(radius) {
    const tier = Math.floor(radius / 10);
    if (tier <= 0) return 0;
    if (tier === 1) return 10;
    let ore = 10; // tier 1 base
    for (let t = 2; t <= tier; t++) {
      const increment = Math.max(4, 11 - Math.ceil(t / 2));
      ore += increment;
    }
    return ore;
  }
  for (let i = asteroids.length - 1; i >= 0; i--) {
    if (asteroids[i].health <= 0) {
      const ast = asteroids[i];
      if (ast._mesh && asteroidContainer) asteroidContainer.remove(ast._mesh);
      const oreCount = calculateOreCount(ast.radius);
      if (oreCount > 0) {
        for (let j = 0; j < oreCount; j++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 30 + Math.random() * 50;
          floatingItems.push({
            x: ast.x,
            y: ast.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            item: ast.oreType || 'cuprite',
            quantity: 1
          });
        }
      }
      asteroids.splice(i, 1);
    }
  }

  // Floating items: magnet + movement + drag
  const MAGNET_RADIUS = 80;
  const MAGNET_STRENGTH = 600; // acceleration (units/sec^2) near ship
  const FLOAT_DRAG = 2.0; // velocity damping per second
  const FLOAT_STOP_SPEED = 0.05;
  for (const item of floatingItems) {
    if (item.vx == null) item.vx = 0;
    if (item.vy == null) item.vy = 0;

    // Magnet attraction (only if inventory can accept this item)
    const dx = ship.x - item.x;
    const dy = ship.y - item.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist > 0 && dist < MAGNET_RADIUS && dist > SHIP_COLLISION_RADIUS && canAcceptFloatingItem(item)) {
      const inv = 1 / dist;
      const pull = MAGNET_STRENGTH * (1 - dist / MAGNET_RADIUS);
      item.vx += dx * inv * pull * dt;
      item.vy += dy * inv * pull * dt;
    }

    // Integrate movement
    item.x += item.vx * dt;
    item.y += item.vy * dt;

    // Collision with asteroids and warp gates: push out so items don't overlap
    const FLOAT_ITEM_RADIUS = 10;
    const STRUCTURE_SIZE_COLL = 54;
    for (const ast of asteroids) {
      const dx = item.x - ast.x;
      const dy = item.y - ast.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const minDist = ast.radius + FLOAT_ITEM_RADIUS;
      if (dist < minDist && dist > 0) {
        const nx = dx / dist;
        const ny = dy / dist;
        const overlap = minDist - dist;
        item.x += nx * overlap;
        item.y += ny * overlap;
      }
    }
    for (const st of structures) {
      if (st.type !== 'warpgate' && st.type !== 'shop' && st.type !== 'piratebase') continue;
      if (st.type === 'piratebase' && (st.dead || st.health <= 0)) continue;
      const dx = item.x - st.x;
      const dy = item.y - st.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const minDist = STRUCTURE_SIZE_COLL + FLOAT_ITEM_RADIUS;
      if (dist < minDist && dist > 0) {
        const nx = dx / dist;
        const ny = dy / dist;
        const overlap = minDist - dist;
        item.x += nx * overlap;
        item.y += ny * overlap;
      }
    }

    // Apply drag (exponential decay)
    const damp = Math.max(0, 1 - FLOAT_DRAG * dt);
    item.vx *= damp;
    item.vy *= damp;

    // Stop tiny drift
    const sp = Math.sqrt(item.vx * item.vx + item.vy * item.vy);
    if (sp < FLOAT_STOP_SPEED) {
      item.vx = 0;
      item.vy = 0;
    }
  }

  // Create/update 3D mesh for ore-type floating items
  const FLOATING_ORE_SCALE = 15; // 40% smaller than before (was 25)
  if (floatingOreContainer && (oreModel || scrapModel)) {
    for (const item of floatingItems) {
      if (!FLOATING_ORE_ITEMS.includes(item.item)) continue;
      const src = (item.item === 'scrap' && scrapModel) ? scrapModel : oreModel;
      if (!src) continue;
      if (!item._mesh) {
        const clone = src.clone(true);
        applyFloatingOreMaterial(clone, item.item);
        clone.scale.setScalar(FLOATING_ORE_SCALE);
        item._mesh = clone;
        floatingOreContainer.add(clone);
        // Random spin: axis, direction, speed (faster than asteroids)
        item._spinAxis = Math.floor(Math.random() * 3); // 0=x, 1=y, 2=z
        item._spinDirection = Math.random() < 0.5 ? -1 : 1;
        item._spinSpeed = 0.5 + Math.random() * 0.4; // 0.5â€“0.9 (faster than asteroids ~0.2â€“0.4)
      }
      item._mesh.position.set(item.x - ship.x, -(item.y - ship.y), 0);
      const spin = (item._spinSpeed ?? 0.6) * (item._spinDirection ?? 1) * dt;
      if (item._spinAxis === 0) item._mesh.rotation.x += spin;
      else if (item._spinAxis === 1) item._mesh.rotation.y += spin;
      else item._mesh.rotation.z += spin;
    }
  }

  // Pickup floating items only when within ship collision radius
  for (let i = floatingItems.length - 1; i >= 0; i--) {
    const item = floatingItems[i];
    const dx = item.x - ship.x;
    const dy = item.y - ship.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < SHIP_COLLECTION_RADIUS) {
      // Energy cells restore their charge - find empty slot
      if (item.energy != null) {
        let added = false;
        for (let j = 0; j < hotbar.length; j++) {
          if (!hotbar[j]) {
            hotbar[j] = { item: item.item, energy: item.energy, maxEnergy: item.maxEnergy };
            added = true;
            break;
          }
        }
        if (added) {
          if (item._mesh && floatingOreContainer) floatingOreContainer.remove(item._mesh);
          floatingItems.splice(i, 1);
        }
      } else if (item.fuel != null) {
        let added = false;
        for (let j = 0; j < hotbar.length; j++) {
          if (!hotbar[j]) {
            hotbar[j] = { item: item.item, fuel: item.fuel, maxFuel: item.maxFuel };
            added = true;
            break;
          }
        }
        if (added) {
          if (item._mesh && floatingOreContainer) floatingOreContainer.remove(item._mesh);
          floatingItems.splice(i, 1);
        }
      } else if (item.oxygen != null && item.item === 'oxygen canister') {
        let added = false;
        for (let j = 0; j < hotbar.length; j++) {
          if (!hotbar[j]) {
            hotbar[j] = { item: item.item, oxygen: item.oxygen, maxOxygen: item.maxOxygen };
            added = true;
            break;
          }
        }
        if (added) {
          if (item._mesh && floatingOreContainer) floatingOreContainer.remove(item._mesh);
          floatingItems.splice(i, 1);
        }
      } else if (item.item === 'mining laser' && item.heat != null) {
        // Mining laser: restore heat/overheated
        let added = false;
        for (let j = 0; j < hotbar.length; j++) {
          if (!hotbar[j]) {
            hotbar[j] = { item: item.item, heat: item.heat, overheated: !!item.overheated };
            added = true;
            break;
          }
        }
        if (added) {
          if (item._mesh && floatingOreContainer) floatingOreContainer.remove(item._mesh);
          floatingItems.splice(i, 1);
        }
      } else if (item.item === 'medium mining laser' && item.heat != null) {
        let added = false;
        for (let j = 0; j < hotbar.length; j++) {
          if (!hotbar[j]) {
            hotbar[j] = { item: item.item, heat: item.heat, overheated: !!item.overheated };
            added = true;
            break;
          }
        }
        if (added) {
          if (item._mesh && floatingOreContainer) floatingOreContainer.remove(item._mesh);
          floatingItems.splice(i, 1);
        }
      } else if (item.item === 'light blaster' && item.heat != null) {
        let added = false;
        for (let j = 0; j < hotbar.length; j++) {
          if (!hotbar[j]) {
            hotbar[j] = { item: item.item, heat: item.heat, overheated: !!item.overheated };
            added = true;
            break;
          }
        }
        if (added) {
          if (item._mesh && floatingOreContainer) floatingOreContainer.remove(item._mesh);
          floatingItems.splice(i, 1);
        }
      } else if (addToInventory(item.item, item.quantity)) {
        if (item._mesh && floatingOreContainer) floatingOreContainer.remove(item._mesh);
        floatingItems.splice(i, 1);
      }
    }
  }

  // Death: show overlay + pause game (one-shot)
  if (!gameState.ui.deathScreenOpen && player.health <= 0) {
    gameState.ui.deathScreenOpen = true;
    gameState.ui.paused = true;
    // Clear latched inputs so nothing keeps firing/thrusting
    inputManager.mouse.left = false;
    inputManager.mouse.right = false;
    inputManager.keys.ctrl = false;
    // Cancel any inventory drag state
    inventoryDrag = null;
    try { setDragGhostVisible(false); } catch (e) {}
    if (deathOverlayEl) deathOverlayEl.style.display = 'flex';
  }
}

function render(dt = 1 / 60) {
  ctx.fillStyle = '#0a0a12';
  ctx.fillRect(0, 0, WIDTH, HEIGHT);

  // Starfield (fillRect is much faster than arc for small shapes)
  for (const star of stars) {
    const sx = star.x - ship.x + WIDTH / 2;
    const sy = star.y - ship.y + HEIGHT / 2;
    if (sx < -10 || sx > WIDTH + 10 || sy < -10 || sy > HEIGHT + 10) continue;
    const s = Math.max(1, star.size);
    ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
    ctx.fillRect(sx - s / 2, sy - s / 2, s, s);
  }

  // Asteroids (2D circles; radius 10-30 use 3D model instead)
  for (const ast of asteroids) {
    if ((ast.radius >= 10 && ast.radius <= 30) || (ast.radius >= 40 && ast.radius <= 90) || ast.radius >= 100) continue;
    const { x, y } = worldToScreen(ast.x, ast.y);
    const r = ast.radius;
    if (x + r < 0 || x - r > WIDTH || y + r < 0 || y - r > HEIGHT) continue;
    
    // Asteroid colors based on ore type
    let fill = '#665544';
    let stroke = '#998877';
    
    if (ast.oreType === 'hematite') { fill = '#8B4513'; stroke = '#A0522D'; }
    else if (ast.oreType === 'aurite') { fill = '#B8860B'; stroke = '#FFD700'; }
    else if (ast.oreType === 'diamite') { fill = '#787878'; stroke = '#909090'; }
    else if (ast.oreType === 'platinite') { fill = '#D3D3D3'; stroke = '#E5E4E2'; }
    
    ctx.fillStyle = fill;
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
  }

  // Pirates
  for (const p of pirates) {
      const { x, y } = worldToScreen(p.x, p.y);
      if (x < -30 || x > WIDTH+30 || y < -30 || y > HEIGHT+30) continue;
      
      // Health Bar
      if (p.health < p.maxHealth) {
          const barW = 32;
          const barH = 4;
          const pct = Math.max(0, p.health / p.maxHealth);
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.fillRect(x - barW/2, y - 25, barW, barH);
          ctx.fillStyle = '#ff3333';
          ctx.fillRect(x - barW/2, y - 25, barW * pct, barH);
      }
  }

  // Floating items in space â€” thin white glow for ore-type (3D) pellets
  for (const item of floatingItems) {
    if (!FLOATING_ORE_ITEMS.includes(item.item)) continue;
    const { x, y } = worldToScreen(item.x, item.y);
    if (x < -30 || x > WIDTH + 30 || y < -30 || y > HEIGHT + 30) continue;
    const r = 14;
    const gradient = ctx.createRadialGradient(x, y, 0, x, y, r);
    gradient.addColorStop(0, 'rgba(255,255,255,0.35)');
    gradient.addColorStop(0.5, 'rgba(255,255,255,0.12)');
    gradient.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
  }
  for (const item of floatingItems) {
    if (FLOATING_ORE_ITEMS.includes(item.item)) continue; // ore-type items rendered as 3D only
    const { x, y } = worldToScreen(item.x, item.y);
    if (x < -20 || x > WIDTH + 20 || y < -20 || y > HEIGHT + 20) continue;
    // Draw small glowing circle - same fill/stroke as ore type
    const oreFill = { cuprite: '#665544', hematite: '#8B4513', aurite: '#B8860B', diamite: '#787878', platinite: '#D3D3D3', scrap: '#888888', 'warp key': '#B8860B' };
    const oreStroke = { cuprite: '#998877', hematite: '#A0522D', aurite: '#FFD700', diamite: '#909090', platinite: '#E5E4E2', scrap: '#aaaaaa', 'warp key': '#DAA520' };
    ctx.fillStyle = item.energy != null ? '#448844' :
                    (item.fuel != null ? '#886622' :
                    (item.oxygen != null ? '#446688' :
                    (item.item === 'light blaster' ? '#6644aa' :
                    (item.heat != null ? '#884422' :
                    (oreFill[item.item] || '#aa8844')))));
    ctx.beginPath();
    ctx.arc(x, y, 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = item.energy != null ? '#66cc66' : (item.fuel != null ? '#cc8844' : (item.oxygen != null ? '#6699cc' : (item.item === 'light blaster' ? '#8866dd' : (item.heat != null ? '#cc6633' : (oreStroke[item.item] || '#ccaa66')))));
    ctx.lineWidth = 2;
    ctx.stroke();
    // Item icon: image for fuel/energy/oxygen, else letter fallback
    const img = ITEM_IMAGES[item.item];
    if (img && img.complete && img.naturalWidth > 0) {
      const size = 18;
      ctx.drawImage(img, x - size / 2, y - size / 2, size, size);
    } else {
      const icon = item.item === 'cuprite' ? 'C' : 
                   (item.item === 'hematite' ? 'H' : 
                   (item.item === 'aurite' ? 'A' : 
                   (item.item === 'diamite' ? 'D' : 
                   (item.item === 'platinite' ? 'P' : 
                   (item.item === 'scrap' ? 'S' : 
                   (item.item === 'warp key' ? 'K' : 
                   (item.item === 'mining laser' ? 'L' : (item.item === 'medium mining laser' ? 'M' : (item.item === 'light blaster' ? 'B' : item.item.charAt(0).toUpperCase())))))))));
      ctx.fillStyle = '#fff';
      ctx.font = '10px Oxanium';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(icon, x, y);
    }
    // Quantity if > 1
    if (item.quantity > 1) {
      ctx.fillStyle = '#ffcc00';
      ctx.font = '8px Oxanium';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'bottom';
      ctx.fillText(item.quantity, x + 12, y + 12);
    }
  }

  // Structures (circles underneath 3D models; 2D circles for other types)
  const STRUCTURE_RADIUS_3D = 54; // 35% bigger than 40
  const WARP_GATE_DASHED_EXTRA_3D = 108; // 80 * 1.35
  const SHOP_DASHED_EXTRA_3D = 108;
  const STRUCTURE_SIZE = 40;
  const WARP_GATE_DASHED_EXTRA = 80;
  const SHOP_DASHED_EXTRA = 80;
  const STRUCTURE_STYLES = { shop: '#446688', shipyard: '#664466', refinery: '#666644', fueling: '#446644', warpgate: '#6644aa', piratebase: '#884422' };
  for (const st of structures) {
    if (st.type === 'piratebase' && (st.dead || st.health <= 0)) continue;
    const is3D = st.type === 'warpgate' || st.type === 'shop' || st.type === 'piratebase';
    const r = is3D ? STRUCTURE_RADIUS_3D : STRUCTURE_SIZE;
    const cullR = st.type === 'warpgate' ? STRUCTURE_RADIUS_3D + WARP_GATE_DASHED_EXTRA_3D : (st.type === 'shop' ? STRUCTURE_RADIUS_3D + SHOP_DASHED_EXTRA_3D : (st.type === 'piratebase' ? PIRATE_BASE_AGGRO_RADIUS : r));
    const { x, y } = worldToScreen(st.x, st.y);
    if (x + cullR < 0 || x - cullR > WIDTH || y + cullR < 0 || y - cullR > HEIGHT) continue;
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 2;
    if (is3D) {
      if (st.type === 'warpgate') {
        ctx.setLineDash([8, 8]);
        ctx.beginPath();
        ctx.arc(x, y, STRUCTURE_RADIUS_3D + WARP_GATE_DASHED_EXTRA_3D, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      } else if (st.type === 'shop') {
        ctx.setLineDash([8, 8]);
        ctx.beginPath();
        ctx.arc(x, y, STRUCTURE_RADIUS_3D + SHOP_DASHED_EXTRA_3D, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      } else if (st.type === 'piratebase') {
        ctx.strokeStyle = STRUCTURE_STYLES.piratebase;
        ctx.setLineDash([10, 10]);
        ctx.beginPath();
        ctx.arc(x, y, PIRATE_BASE_AGGRO_RADIUS, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
        // Health bar when damaged
        if (st.health < st.maxHealth) {
          const barW = 90;
          const barH = 6;
          const pct = Math.max(0, st.health / st.maxHealth);
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.fillRect(x - barW/2, y - STRUCTURE_RADIUS_3D - 20, barW, barH);
          ctx.fillStyle = '#ff3333';
          ctx.fillRect(x - barW/2, y - STRUCTURE_RADIUS_3D - 20, barW * pct, barH);
        }
      }
    } else {
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fillStyle = STRUCTURE_STYLES[st.type] || '#446688';
      ctx.fill();
      if (st.type === 'warpgate') {
        ctx.stroke();
        ctx.setLineDash([8, 8]);
        ctx.beginPath();
        ctx.arc(x, y, STRUCTURE_SIZE + WARP_GATE_DASHED_EXTRA, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      } else if (st.type === 'shop') {
        ctx.stroke();
        ctx.setLineDash([8, 8]);
        ctx.beginPath();
        ctx.arc(x, y, STRUCTURE_SIZE + SHOP_DASHED_EXTRA, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      } else {
        ctx.stroke();
      }
    }
    if (is3D) continue;
    ctx.fillStyle = '#fff';
    ctx.font = '14px Oxanium';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const label = st.type === 'warpgate' ? 'W' : (st.type === 'piratebase' ? 'P' : (st.type ? st.type.charAt(0).toUpperCase() : '?'));
    ctx.fillText(label, x, y);
  }

  // Bullets (fillRect faster than arc)
  for (const b of bullets) {
    const { x, y } = worldToScreen(b.x, b.y);
    ctx.fillStyle = '#ffcc00';
    ctx.fillRect(x - 2, y - 2, 4, 4);
  }

  // Spark particles
  for (const p of particles) {
    const { x, y } = worldToScreen(p.x, p.y);
    if (x < -10 || x > WIDTH + 10 || y < -10 || y > HEIGHT + 10) continue;
    const alpha = p.life / p.maxLife;
    const r = 255;
    const g = Math.round(150 + 105 * alpha); // yellow to orange
    const b = Math.round(50 * alpha);
    ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
    ctx.fillRect(x - p.size / 2, y - p.size / 2, p.size, p.size);
  }

  // Update 3D asteroid positions (camera-follow coordinates; negate Y to match 2D canvas)
  for (const ast of asteroids) {
    if (ast._mesh) {
      ast._mesh.position.set(ast.x - ship.x, -(ast.y - ship.y), 0);
      const spin = (ast._spinSpeed ?? 0.3) * (ast._spinDirection ?? 1) * dt;
      if (ast._spinAxis === 0) ast._mesh.rotation.x += spin;
      else if (ast._spinAxis === 1) ast._mesh.rotation.y += spin;
      else ast._mesh.rotation.z += spin;
    }
  }

  // Update 3D structure positions (camera-follow coordinates; negate Y to match 2D canvas)
  for (const st of structures) {
    if (st._mesh) {
      const yOff = st.type === 'shop' ? 4 : 0;
      st._mesh.position.set(st.x - ship.x, -(st.y - ship.y) + yOff, 0);
    }
  }

  // Update 3D pirate positions
  for (const p of pirates) {
    if (!p._mesh && pirateModel && pirateContainer) {
        const clone = pirateModel.clone(true);
        pirateContainer.add(clone);
        p._mesh = clone;
    }
    if (p._mesh) {
        p._mesh.position.set(p.x - ship.x, -(p.y - ship.y), 0);
        p._mesh.rotation.x = -Math.PI / 2;
        p._mesh.rotation.y = p.facingAngle + Math.PI / 2;
        p._mesh.rotation.z = p.tilt || 0;
        p._mesh.visible = true;
    }
  }

  // Ship: 3D model if loaded, else 2D triangle
  const cx = WIDTH / 2;
  const cy = HEIGHT / 2;
  const aimAngle = Math.atan2(inputManager.mouse.y - cy, inputManager.mouse.x - cx);
  // Always clear the ship canvas so it stays transparent before model load.
  if (shipRenderer) shipRenderer.clear();
  if (shipModelLoaded && shipMesh && shipRenderer && shipScene && shipCamera) {
    // Tilt when turning, decay when resting
    if (!shipTiltInitialized) {
      prevAimAngle = aimAngle;
      shipTiltInitialized = true;
    }
    let deltaAngle = aimAngle - prevAimAngle;
    while (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
    while (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
    prevAimAngle = aimAngle;
    const TILT_SENSITIVITY = 8;
    const TILT_DECAY = 4;
    shipTilt += deltaAngle * TILT_SENSITIVITY - shipTilt * TILT_DECAY * dt;
    shipTilt = Math.max(-0.5, Math.min(0.5, shipTilt));
    shipMesh.rotation.y = aimAngle + Math.PI / 2;
    shipMesh.rotation.z = shipTilt;
    // Show thruster flames when thrusting
    const thrustDx = inputManager.mouse.x - WIDTH / 2;
    const thrustDy = inputManager.mouse.y - HEIGHT / 2;
    const isThrusting = inputManager.mouse.right && player.fuel > 0 && (thrustDx !== 0 || thrustDy !== 0);
    for (const flame of shipFlames) {
      flame.visible = isThrusting;
      flame.rotation.z = shipTilt; // Tilt flames with ship
      if (isThrusting) {
        // Animate flame length from base (oscillate between 0.7 and 1.3)
        const flicker = 1 + 0.3 * Math.sin(performance.now() * 0.02);
        flame.scale.set(1, 1, flicker);
      }
    }
    shipRenderer.render(shipScene, shipCamera);
  } else {
    drawShip2D();
  }
  drawCrosshairAndHeatBar();

  // Mining laser beam (orange-red line) - any mining laser in MINING_LASER_STATS
  const hasEnergy = getFirstChargedCell() != null;
  const selectedItem = hotbar[gameState.selectedSlot];
  const miningLaser = selectedItem && MINING_LASER_STATS[selectedItem.item] ? selectedItem : null;
  const canFire = miningLaser && !miningLaser.overheated;
  if (miningLaser && inputManager.mouse.left && hasEnergy && canFire) {
    const cx = WIDTH / 2;
    const cy = HEIGHT / 2;
    const dx = inputManager.mouse.x - cx;
    const dy = inputManager.mouse.y - cy;
    const dir = normalize(dx, dy);
    // Cap at screen edge (world units; 1:1 with screen, ship at center)
    let maxLaserDist = 1500;
    if (Math.abs(dir.x) > 1e-6) maxLaserDist = Math.min(maxLaserDist, (WIDTH / 2) / Math.abs(dir.x));
    if (Math.abs(dir.y) > 1e-6) maxLaserDist = Math.min(maxLaserDist, (HEIGHT / 2) / Math.abs(dir.y));
    let laserLength = maxLaserDist;
    
    // Check for asteroid or pirate hit and shorten laser (stop before surface)
    if (dir.x !== 0 || dir.y !== 0) {
      const hit = laserHitAsteroid(ship.x, ship.y, dir.x, dir.y, maxLaserDist);
      if (hit) {
        laserLength = Math.min(laserLength, Math.max(0, hit.distance - 10));
      }
      // Check pirates: ray-circle intersection, use closest hit
      const pirateRadius = SHIP_COLLISION_RADIUS + 4;
      for (const p of pirates) {
        const fx = p.x - ship.x;
        const fy = p.y - ship.y;
        const t = fx * dir.x + fy * dir.y;
        if (t < 0) continue;
        const cxW = ship.x + dir.x * t;
        const cyW = ship.y + dir.y * t;
        const distSq = (p.x - cxW) * (p.x - cxW) + (p.y - cyW) * (p.y - cyW);
        if (distSq < pirateRadius * pirateRadius) {
          const offset = Math.sqrt(pirateRadius * pirateRadius - distSq);
          const tHit = t - offset;
          if (tHit > 0 && tHit < laserLength) {
            laserLength = Math.max(0, tHit - 4);
          }
        }
      }
      // Check pirate bases: ray-circle intersection (radius 54)
      const baseHit = laserHitPirateBase(ship.x, ship.y, dir.x, dir.y, laserLength);
      if (baseHit) {
        laserLength = Math.min(laserLength, Math.max(0, baseHit.distance - 10));
      }
    }
    const x1 = cx + dir.x * SHIP_SIZE;
    const y1 = cy + dir.y * SHIP_SIZE;
    let maxL = laserLength;
    if (dir.x > 0) maxL = Math.min(maxL, (WIDTH - x1) / dir.x);
    else if (dir.x < 0) maxL = Math.min(maxL, -x1 / dir.x);
    if (dir.y > 0) maxL = Math.min(maxL, (HEIGHT - y1) / dir.y);
    else if (dir.y < 0) maxL = Math.min(maxL, -y1 / dir.y);
    laserLength = Math.max(0, Math.min(laserLength, maxL));
    const x2 = x1 + dir.x * laserLength;
    const y2 = y1 + dir.y * laserLength;
    // Interpolate color based on heat: orange when cool, deep red when hot
    const heat = miningLaser.heat || 0;
    const outerR = Math.round(255 - heat * 55); // 255 -> 200
    const outerG = Math.round(102 - heat * 102); // 102 -> 0
    const outerB = 0;
    const innerR = Math.round(255 - heat * 55); // 255 -> 200
    const innerG = Math.round(136 - heat * 136); // 136 -> 0
    const innerB = Math.round(68 - heat * 68); // 68 -> 0
    ctx.strokeStyle = `rgb(${outerR},${outerG},${outerB})`;
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.strokeStyle = `rgb(${innerR},${innerG},${innerB})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  // Interaction prompt for nearby interactable structures (shop, warpgate)
  {
    const interactRadius = 54 + 108;
    let nearestInteractable = null;
    let nearestDist = Infinity;
    if (!gameState.ui.shopMenuOpen) {
      for (const st of structures) {
        if (st.type !== 'shop' && st.type !== 'warpgate') continue;
        const dx = ship.x - st.x;
        const dy = ship.y - st.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < interactRadius && dist < nearestDist) {
          nearestDist = dist;
          nearestInteractable = st;
        }
      }
    }
    // Fade in/out
    const fadeSpeed = 6; // per second
    if (nearestInteractable) {
      gameState.ui.interactPromptTarget = nearestInteractable;
      gameState.ui.interactPromptAlpha = Math.min(1, gameState.ui.interactPromptAlpha + fadeSpeed * dt);
    } else {
      gameState.ui.interactPromptAlpha = Math.max(0, gameState.ui.interactPromptAlpha - fadeSpeed * dt);
    }
    // Draw with alpha (above the 3D model)
    if (gameState.ui.interactPromptAlpha > 0 && gameState.ui.interactPromptTarget) {
      const { x, y } = worldToScreen(gameState.ui.interactPromptTarget.x, gameState.ui.interactPromptTarget.y);
      const label = gameState.ui.interactPromptTarget.type === 'shop' ? 'Shop' : 'Warp Gate';
      const a = gameState.ui.interactPromptAlpha;
      const topY = y - 95; // Above 3D model (radius ~54 + padding)
      ctx.font = 'bold 14px Oxanium';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillStyle = `rgba(0,0,0,${a})`;
      ctx.fillText(label, x + 1, topY + 1);
      ctx.fillStyle = `rgba(255,255,255,${a})`;
      ctx.fillText(label, x, topY);
      ctx.font = '12px Oxanium';
      ctx.textBaseline = 'top';
      ctx.fillStyle = `rgba(0,0,0,${a})`;
      ctx.fillText('Press E to interact', x + 1, topY + 4);
      ctx.fillStyle = `rgba(170,170,170,${a})`;
      ctx.fillText('Press E to interact', x, topY + 3);
    }
    if (gameState.ui.interactPromptAlpha <= 0) gameState.ui.interactPromptTarget = null;
  }

  // Tutorial text (visible until first thrust, then 10s + 1s fade)
  if (gameState.ui.tutorialTextTimer > 0 || !gameState.ui.gameState.ui.tutorialTextTimerStarted) {
    if (gameState.ui.gameState.ui.tutorialTextTimerStarted) gameState.ui.tutorialTextTimer -= dt;
    const fadeStart = 1; // Start fading at 1 second remaining
    const alpha = !gameState.ui.gameState.ui.tutorialTextTimerStarted ? 1 : (gameState.ui.tutorialTextTimer > fadeStart ? 1 : Math.max(0, gameState.ui.tutorialTextTimer / fadeStart));
    if (alpha > 0) {
      const { x, y } = worldToScreen(gameState.ui.tutorialTextWorldX, gameState.ui.tutorialTextWorldY);
      const lines = [
        'Left click to fire.',
        'Right click to thrust.',
        'Ctrl to brake.'
      ];
      ctx.font = '14px Oxanium';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const lineHeight = 20;
      const startY = y - ((lines.length - 1) * lineHeight) / 2;
      for (let i = 0; i < lines.length; i++) {
        const ly = startY + i * lineHeight;
        ctx.fillStyle = `rgba(0,0,0,${alpha})`;
        ctx.fillText(lines[i], x + 1, ly + 1);
        ctx.fillStyle = `rgba(255,255,255,${alpha})`;
        ctx.fillText(lines[i], x, ly);
      }
    }
  }

  // Player stats meters (bottom right) - bar height in pixels = max value in units
  if (uiCtx) {
    const meterWidth = 40;
    const meterSpacing = 50;
    const meterY = HEIGHT - 20;

    function drawMeter(x, value, max, color, label) {
      const barHeight = max * 2; // 2 pixels per unit
      const fillH = (value / max) * barHeight;
      // Background
      uiCtx.fillStyle = '#222';
      uiCtx.fillRect(x - meterWidth / 2, meterY - barHeight, meterWidth, barHeight);
      // Fill
      uiCtx.fillStyle = color;
      uiCtx.fillRect(x - meterWidth / 2, meterY - fillH, meterWidth, fillH);
      // Border
      uiCtx.strokeStyle = '#555';
      uiCtx.lineWidth = 1;
      uiCtx.strokeRect(x - meterWidth / 2, meterY - barHeight, meterWidth, barHeight);
      // Label
      uiCtx.fillStyle = '#aaa';
      uiCtx.font = '10px Oxanium';
      uiCtx.textAlign = 'center';
      uiCtx.textBaseline = 'top';
      uiCtx.fillText(label, x, meterY + 4);
      // Value
      uiCtx.fillStyle = '#fff';
      uiCtx.textBaseline = 'bottom';
      uiCtx.fillText(value.toFixed(1), x, meterY - barHeight - 2);
    }

    const rightmost = WIDTH - 30;
    drawMeter(rightmost - 100, player.oxygen, player.maxOxygen, '#44aaff', 'O2');
    drawMeter(rightmost - 50, player.fuel, player.maxFuel, '#ffaa44', 'Fuel');
    drawMeter(rightmost, player.health, player.maxHealth, '#ff4444', 'HP');
  }
}

// Input
inputManager.on('wheel', (e) => {
  e.preventDefault();
  if (gameState.ui.gameState.ui.startScreenOpen || gameState.ui.gameState.ui.deathScreenOpen) return;
  if (gameState.ui.gameState.ui.warpMenuOpen) return;
  if (gameState.ui.gameState.ui.shopMenuOpen) return;
  if (e.deltaY > 0) {
    gameState.gameState.selectedSlot = (gameState.gameState.selectedSlot + 1) % 9;
  } else {
    gameState.gameState.selectedSlot = (gameState.gameState.selectedSlot - 1 + 9) % 9;
  }
});

function isShipInWarpGate() {
  const interactRadius = 54 + 108; // base 35% bigger
  for (const st of structures) {
    if (st.type !== 'warpgate') continue;
    const dx = ship.x - st.x;
    const dy = ship.y - st.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < interactRadius) return st;
  }
  return null;
}

function isShipInShop() {
  const interactRadius = 54 + 108; // base 35% bigger
  for (const st of structures) {
    if (st.type !== 'shop') continue;
    const dx = ship.x - st.x;
    const dy = ship.y - st.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < interactRadius) return st;
  }
  return null;
}

function hasCuprite() {
  for (let i = 0; i < hotbar.length; i++) {
    if (hotbar[i] && hotbar[i].item === 'cuprite' && hotbar[i].quantity > 0) return true;
  }
  return false;
}

function hasEmptyHotbarSlot() {
  for (let i = 0; i < hotbar.length; i++) {
    if (!hotbar[i]) return true;
  }
  return false;
}

// Can we accept this floating item (for magnet: don't attract if inventory can't take it)
function canAcceptFloatingItem(item) {
  if (item.energy != null || item.fuel != null || item.oxygen != null || (item.item === 'mining laser' && item.heat != null) || (item.item === 'medium mining laser' && item.heat != null) || (item.item === 'light blaster' && item.heat != null)) {
    return hasEmptyHotbarSlot();
  }
  const qty = item.quantity != null ? item.quantity : 1;
  const maxStack = getMaxStack(item.item);
  let space = 0;
  for (let i = 0; i < hotbar.length; i++) {
    const cell = hotbar[i];
    if (!cell) space += maxStack;
    else if (cell.item === item.item && cell.quantity != null && cell.quantity < maxStack) {
      space += maxStack - cell.quantity;
    }
  }
  return space >= qty;
}

// Shop: buy/sell 5x3 grid (15 slots)
const ITEM_BUY_PRICE = { 
  'small energy cell': 150, 
  'medium energy cell': 550, 
  'oxygen canister': 500, 
  'fuel tank': 300, 
  'light blaster': 1000, 
  'medium mining laser': 1500,
  'health pack': 400,
  'large health pack': 1000,
  'large fuel tank': 750,
  'large oxygen canister': 1250
};
const ITEM_SELL_PRICE = { cuprite: 10, hematite: 20, aurite: 30, diamite: 40, platinite: 60, scrap: 40, 'warp key': 500, 'mining laser': 300, 'light blaster': 500, 'medium mining laser': 750 };
const shopBuySlots = Array(15).fill(null);
const shopSellSlots = Array(15).fill(null);

function initShopBuySlots() {
  // Global init removed, handled per shop instance
}

// Remove one unit of an item from the active shop structure's persistent inventory
function removeFromShopInventory(itemKey) {
  if (!gameState.ui.activeShopStructure || !gameState.ui.activeShopStructure.inventory) return;
  const inv = gameState.ui.activeShopStructure.inventory;
  const idx = inv.findIndex(entry => entry.item === itemKey);
  if (idx === -1) return;
  const entry = inv[idx];
  const qty = entry.quantity || 1;
  if (qty > 1) {
    entry.quantity = qty - 1;
  } else {
    inv.splice(idx, 1);
  }
}

function getShopItemPayload(itemKey) {
  if (itemKey === 'small energy cell') {
    return { item: 'small energy cell', energy: 10, maxEnergy: 10 };
  }
  if (itemKey === 'medium energy cell') {
    return { item: 'medium energy cell', energy: 30, maxEnergy: 30 };
  }
  if (itemKey === 'oxygen canister') {
    return { item: 'oxygen canister', oxygen: 10, maxOxygen: 10 };
  }
  if (itemKey === 'large oxygen canister') {
    return { item: 'large oxygen canister', oxygen: 30, maxOxygen: 30 };
  }
  if (itemKey === 'fuel tank') {
    return { item: 'fuel tank', fuel: 10, maxFuel: 10 };
  }
  if (itemKey === 'large fuel tank') {
    return { item: 'large fuel tank', fuel: 30, maxFuel: 30 };
  }
  if (itemKey === 'health pack') {
    return { item: 'health pack', health: 10 };
  }
  if (itemKey === 'large health pack') {
    return { item: 'large health pack', health: 30 };
  }
  if (itemKey === 'light blaster') {
    return { item: 'light blaster', heat: 0, overheated: false };
  }
  if (itemKey === 'medium mining laser') {
    return { item: 'medium mining laser', heat: 0, overheated: false };
  }
  return { item: itemKey };
}

function getItemLabel(it) {
  if (!it) return '';
  if (it.item === 'mining laser') return 'L';
  if (it.item === 'medium mining laser') return 'M';
  if (it.item === 'light blaster') return 'B';
  if (it.item === 'small energy cell') return 'E';
  if (it.item === 'medium energy cell') return 'M';
  if (it.item === 'oxygen canister') return 'O';
  if (it.item === 'large oxygen canister') return 'LO';
  if (it.item === 'fuel tank') return 'F';
  if (it.item === 'large fuel tank') return 'LF';
  if (it.item === 'health pack') return 'H';
  if (it.item === 'large health pack') return 'LH';
  if (it.item === 'cuprite') return 'C';
  if (it.item === 'hematite') return 'H';
  if (it.item === 'aurite') return 'A';
  if (it.item === 'diamite') return 'D';
  if (it.item === 'platinite') return 'P';
  if (it.item === 'scrap') return 'S';
  if (it.item === 'warp key') return 'K';
  return (it.item && it.item.charAt(0).toUpperCase()) || '';
}

function getWeaponTierLetter(itemKey) {
  if (itemKey === 'light blaster' || itemKey === 'mining laser') return 'L';
  if (itemKey === 'medium mining laser') return 'M';
  return null;
}

function getSlotHTML(it) {
  let html = '';
  if (it) {
    const imgPath = getItemImagePath(it.item);
    const oreIconUrl = FLOATING_ORE_ITEMS.includes(it.item) ? ORE_ICON_DATA_URLS[it.item] : null;
    if (oreIconUrl) {
      html += `<div class="slot-icon slot-icon-ore-wrap"><img src="${oreIconUrl}" class="slot-icon-ore-bg" alt=""><span class="slot-icon-ore-letter">${getItemLabel(it)}</span></div>`;
    } else if (imgPath) {
      html += `<img src="${imgPath}" class="slot-icon slot-icon-img" alt="">`;
    } else {
      html += `<span class="slot-icon">${getItemLabel(it)}</span>`;
    }
    const tierLetter = getWeaponTierLetter(it.item);
    if (tierLetter) html += `<span class="slot-tier">${tierLetter}</span>`;

    // Mining laser: heat bar (red)
    if (it.item === 'mining laser' && it.heat != null) {
      const fillH = Math.round(32 * it.heat);
      html += `<div class="slot-bar"><div class="slot-bar-fill" style="height:${fillH}px;background:#cc2222;"></div></div>`;
    }
    // Medium mining laser: heat bar (red)
    if (it.item === 'medium mining laser' && it.heat != null) {
      const fillH = Math.round(32 * it.heat);
      html += `<div class="slot-bar"><div class="slot-bar-fill" style="height:${fillH}px;background:#cc2222;"></div></div>`;
    }
    // Light blaster: heat bar (red)
    if (it.item === 'light blaster' && it.heat != null) {
      const fillH = Math.round(32 * it.heat);
      html += `<div class="slot-bar"><div class="slot-bar-fill" style="height:${fillH}px;background:#cc2222;"></div></div>`;
    }
    
    // Energy cell: energy value + charge bar
    if (it.energy != null) {
      html += `<span class="slot-energy">${it.energy.toFixed(1)}</span>`;
      const charge = it.maxEnergy > 0 ? it.energy / it.maxEnergy : 0;
      const fillH = Math.round(32 * charge);
      const color = charge > 0.5 ? '#66ff66' : (charge > 0.25 ? '#ffff66' : '#ff6666');
      html += `<div class="slot-bar"><div class="slot-bar-fill" style="height:${fillH}px;background:${color};"></div></div>`;
    } else if (it.fuel != null) {
      // Fuel cell: fuel value + charge bar (orange)
      html += `<span class="slot-energy">${it.fuel.toFixed(1)}</span>`;
      const charge = it.maxFuel > 0 ? it.fuel / it.maxFuel : 0;
      const fillH = Math.round(32 * charge);
      const color = charge > 0.5 ? '#ffaa44' : (charge > 0.25 ? '#ffcc66' : '#ff8844');
      html += `<div class="slot-bar"><div class="slot-bar-fill" style="height:${fillH}px;background:${color};"></div></div>`;
    } else if ((it.item === 'oxygen canister' || it.item === 'large oxygen canister') && it.oxygen != null) {
      // Oxygen canister: oxygen value + charge bar (blue)
      html += `<span class="slot-energy">${it.oxygen.toFixed(1)}</span>`;
      const charge = it.maxOxygen > 0 ? it.oxygen / it.maxOxygen : 0;
      const fillH = Math.round(32 * charge);
      const color = charge > 0.5 ? '#66aaff' : (charge > 0.25 ? '#88ccff' : '#4488dd');
      html += `<div class="slot-bar"><div class="slot-bar-fill" style="height:${fillH}px;background:${color};"></div></div>`;
    } else if ((it.item === 'health pack' || it.item === 'large health pack') && it.health != null) {
      // Health pack: health value + charge bar (reddish)
      html += `<span class="slot-energy">${it.health.toFixed(1)}</span>`;
      const maxHealth = it.item === 'large health pack' ? 30 : 10;
      const charge = it.health / maxHealth;
      const fillH = Math.round(32 * charge);
      const color = '#ff4444';
      html += `<div class="slot-bar"><div class="slot-bar-fill" style="height:${fillH}px;background:${color};"></div></div>`;
    } else if (it.quantity != null && it.quantity > 1) {
      html += `<span class="slot-qty">${it.quantity}</span>`;
    }
  }
  return html;
}

const SMALL_ENERGY_CELL_FULL_SELL = 150;
const MEDIUM_ENERGY_CELL_FULL_SELL = 550;
const ENERGY_CELL_MIN_SELL = 10;

function getItemSellPrice(item) {
  if (!item) return 0;
  // Small energy cell: proportional to charge, min ENERGY_CELL_MIN_SELL cr
  if (item.item === 'small energy cell' && item.energy != null && item.maxEnergy != null) {
    const chargeRatio = item.maxEnergy > 0 ? item.energy / item.maxEnergy : 0;
    return Math.max(ENERGY_CELL_MIN_SELL, Math.round(SMALL_ENERGY_CELL_FULL_SELL * chargeRatio));
  }
  // Medium energy cell: proportional to charge, min ENERGY_CELL_MIN_SELL cr
  if (item.item === 'medium energy cell' && item.energy != null && item.maxEnergy != null) {
    const chargeRatio = item.maxEnergy > 0 ? item.energy / item.maxEnergy : 0;
    return Math.max(ENERGY_CELL_MIN_SELL, Math.round(MEDIUM_ENERGY_CELL_FULL_SELL * chargeRatio));
  }
  // Fuel tank and oxygen canister: always sell for half of purchase price
  if (['fuel tank', 'large fuel tank', 'oxygen canister', 'large oxygen canister', 'health pack', 'large health pack'].includes(item.item)) {
    const buy = ITEM_BUY_PRICE[item.item];
    return buy != null ? Math.floor(buy / 2) : 0;
  }
  // Static prices for other items
  const price = ITEM_SELL_PRICE[item.item];
  return price != null ? price : 0;
}

function getItemBuyPrice(itemKey) {
  // Check for custom shop price override first
  if (gameState.ui.activeShopStructure && gameState.ui.activeShopStructure.prices && gameState.ui.activeShopStructure.prices[itemKey] !== undefined) {
    return gameState.ui.activeShopStructure.prices[itemKey];
  }
  // Fall back to default price
  return ITEM_BUY_PRICE[itemKey] || 0;
}

function getSellTotal() {
  let total = 0;
  for (const slot of shopSellSlots) {
    if (!slot) continue;
    const price = getItemSellPrice(slot);
    const qty = slot.quantity != null ? slot.quantity : 1;
    total += price * qty;
  }
  return total;
}

function syncShopBuyArea() {
  for (let i = 0; i < shopBuySlots.length; i++) {
    const el = document.querySelector(`#shop-buy-slots .shop-buy-slot[data-buy-slot="${i}"]`);
    if (!el) continue;
    const it = shopBuySlots[i];
    el.classList.toggle('has-item', !!it);
    
    // We can reuse getSlotHTML, but buy slots don't usually need dynamic heat/energy bars if they are static store items.
    // However, our shop items DO have energy/maxEnergy properties (like energy cells).
    // So getSlotHTML works fine.
    
    el.innerHTML = getSlotHTML(it);
  }
  
    // Build price list - only items in this shop, sorted by price
    const itemNames = { 
      'small energy cell': 'Small Energy Cell',
      'medium energy cell': 'Medium Energy Cell', 
      'fuel tank': 'Fuel Tank', 
      'large fuel tank': 'Large Fuel Tank',
      'oxygen canister': 'Oxygen Canister',
      'large oxygen canister': 'Large Oxygen Canister',
      'health pack': 'Health Pack',
      'large health pack': 'Large Health Pack',
      'light blaster': 'Light Blaster',
      'medium mining laser': 'Medium Mining Laser',
      cuprite: 'Cuprite',
      hematite: 'Hematite',
      aurite: 'Aurite',
      diamite: 'Diamite',
      platinite: 'Platinite',
      'scrap': 'Scrap',
      'warp key': 'Warp Key'
    };
    let html = '';
    
    // Only include items that are in this shop's inventory
    const shopItems = new Set();
    if (gameState.ui.activeShopStructure && gameState.ui.activeShopStructure.inventory) {
      gameState.ui.activeShopStructure.inventory.forEach(i => shopItems.add(i.item));
    }
    
    // Sort by price (ascending)
    const sortedItems = Array.from(shopItems)
      .map(itemKey => ({ itemKey, price: getItemBuyPrice(itemKey) }))
      .filter(x => x.price > 0)
      .sort((a, b) => a.price - b.price);
    
    for (const { itemKey, price } of sortedItems) {
      const label = itemNames[itemKey] || itemKey;
      html += `<div class="price-row"><span class="price-label">${label}</span><span class="price-value">${price} cr</span></div>`;
    }
    const priceList = document.getElementById('shop-price-list');
    if (priceList) priceList.innerHTML = html;
}


function updateHUD() {
  // Sync Hotbar
  for (let i = 0; i < 9; i++) {
    const el = document.querySelector(`#hotbar .slot[data-slot="${i}"]`);
    if (!el) continue;
    const it = hotbar[i];
    el.classList.toggle('has-item', !!it);
    el.classList.toggle('selected', i === gameState.selectedSlot);
    
    let html = `<span class="slot-num">${i + 1}</span>`;
    html += getSlotHTML(it);
    el.innerHTML = html;
  }
  
  // Sync Credits
  const valueEl = document.querySelector('.credits-value');
  if (valueEl) valueEl.textContent = player.credits;
  const shopCreditsEl = document.getElementById('shop-credits-display');
  if (shopCreditsEl) shopCreditsEl.textContent = `You have ${player.credits} credits`;
}

// Alias for compatibility if needed, or I can replace calls
const syncShopHotbar = updateHUD;
const syncShopCredits = updateHUD;

function syncShopSellArea() {
  for (let i = 0; i < shopSellSlots.length; i++) {
    const el = document.querySelector(`#shop-sell-slots .shop-sell-slot[data-sell-slot="${i}"]`);
    if (!el) continue;
    const it = shopSellSlots[i];
    el.classList.toggle('has-item', !!it);
    
    el.innerHTML = getSlotHTML(it);
  }
  const totalEl = document.getElementById('shop-sell-total');
  if (totalEl) totalEl.textContent = `Total: ${getSellTotal()} credits`;
  const sellBtn = document.getElementById('shop-sell-btn');
  if (sellBtn) sellBtn.disabled = getSellTotal() === 0;
}

// syncShopCredits merged into updateHUD


function returnSellAreaToHotbar() {
  for (let i = 0; i < shopSellSlots.length; i++) {
    const it = shopSellSlots[i];
    if (!it) continue;
    const qty = it.quantity != null ? it.quantity : 1;
    if (ORE_ITEMS.includes(it.item)) {
      addToInventory(it.item, qty);
    } else {
      for (let k = 0; k < qty; k++) {
        const payload = { ...it };
        if (payload.quantity != null) delete payload.quantity;
        for (let j = 0; j < hotbar.length; j++) {
          if (!hotbar[j]) {
            hotbar[j] = { ...payload };
            break;
          }
        }
      }
    }
    shopSellSlots[i] = null;
  }
  syncShopSellArea();
}

inputManager.on('keydown', (e) => {
  if (gameState.ui.gameState.ui.startScreenOpen || gameState.ui.gameState.ui.deathScreenOpen) return;
  if (gameState.ui.gameState.ui.warpMenuOpen) return;
  if (gameState.ui.gameState.ui.shopMenuOpen) {
    // Allow E to close shop, ignore other gameplay inputs while paused in menu
    if (e.code === 'KeyE') {
      e.preventDefault();
      closeShopMenu();
    }
    return;
  }
  // Hotbar slot selection (1-9)
  if (e.key >= '1' && e.key <= '9') {
    gameState.gameState.selectedSlot = parseInt(e.key) - 1;
  }
  // Key in E position (KeyE): close shop, or open warp gate/shop menu when inside
  if (e.code === 'KeyE') {
    if (!gameState.ui.gameState.ui.warpMenuOpen && !gameState.ui.paused && isShipInWarpGate()) {
      e.preventDefault();
      inputManager.reset();
      gameState.ui.paused = true;
      gameState.ui.gameState.ui.warpMenuOpen = true;
      const overlay = document.getElementById('warp-menu-overlay');
      if (overlay) overlay.style.display = 'flex';
      const payBtn = document.getElementById('warp-pay-btn');
      if (payBtn) payBtn.disabled = ship.credits < 3000;
    } else if (!gameState.ui.gameState.ui.warpMenuOpen && !gameState.ui.paused) {
      const shopSt = isShipInShop();
      if (shopSt) {
        e.preventDefault();
        inputManager.reset();
        openShopMenu(shopSt);
      }
    }
  }
});
// keyup handled by InputManager state

// Default shop inventory generator
function generateDefaultShopInventory() {
  const inv = [];
  inv.push({ item: 'light blaster', heat: 0, overheated: false });
  inv.push({ item: 'medium mining laser', heat: 0, overheated: false });
  for (let i = 0; i < 6; i++) inv.push({ item: 'small energy cell', energy: 10, maxEnergy: 10 });
  inv.push({ item: 'medium energy cell', energy: 30, maxEnergy: 30 });
  inv.push({ item: 'medium energy cell', energy: 30, maxEnergy: 30 });
  for (let i = 0; i < 3; i++) inv.push({ item: 'fuel tank', fuel: 10, maxFuel: 10 });
  for (let i = 0; i < 2; i++) inv.push({ item: 'oxygen canister', oxygen: 10, maxOxygen: 10 });
  return inv;
}

let gameState.level.spawnSettings = {
  initialDelay: 120,
  waveIntervalMin: 60,
  waveIntervalMax: 100,
  waveSizeMin: 2,
  waveSizeMax: 4
};

// Load level from JSON file
function loadLevel(levelData) {
  // Reset ship position and velocity
  ship.x = 0;
  ship.y = 0;
  ship.vx = 0;
  ship.vy = 0;
  
  gameState.level.width = levelData.width || 10000;
  gameState.level.height = levelData.height || 10000;
  
  if (levelData.spawnSettings) {
    gameState.level.spawnSettings = levelData.spawnSettings;
    if (!gameState.level.spawnSettings.tiers) gameState.level.spawnSettings.tiers = [];
  } else {
    // Default
    gameState.level.spawnSettings = {
      initialDelay: 120,
      waveIntervalMin: 60,
      waveIntervalMax: 100,
      waveSizeMin: 2,
      waveSizeMax: 4,
      tiers: []
    };
  }

  // Health multipliers by ore type
  const oreHealthMult = { cuprite: 1, hematite: 3, aurite: 5, diamite: 8, platinite: 12 };
  asteroids = (levelData.asteroids || []).map(ast => {
    const baseHealth = ast.radius;
    const mult = oreHealthMult[ast.oreType] || 1;
    return {
      ...ast,
      health: ast.health ?? (baseHealth * mult)
    };
  });
  structures = (levelData.structures || []).map(s => {
    // Preserve all properties from editor
    const st = { ...s };
    st.x = Number(s.x) || 0;
    st.y = Number(s.y) || 0;
    st.type = String(s.type || 'shop');

    if (st.type === 'shop') {
      if (!st.inventory) st.inventory = generateDefaultShopInventory();
      if (!st.prices) st.prices = {};
    }
    
    if (st.type === 'piratebase') {
      // Use config health or default 150
      const hp = st.health || 150;
      st.health = hp;
      st.maxHealth = hp;
      st.aggroed = false;
      st.spawnTimer = st.spawnRate || 30; // Wait full spawn time before first wave
      // Default defense count if not set
      if (st.defenseCount === undefined) st.defenseCount = 8;
      // Default spawn rate if not set
      if (st.spawnRate === undefined) st.spawnRate = 30;
      // Default drops if not set
      if (!st.drops) st.drops = []; // Will fallback to default in onPirateBaseDeath if empty? No, better to pre-fill or handle empty logic. 
      // Actually, existing logic hardcoded drops. If st.drops is empty, we might want to default it?
      // Editor saves empty array if nothing added. 
      // Let's populate default drops if it's missing entirely (undefined), but respect empty array if user cleared it.
      if (s.drops === undefined) {
        st.drops = [
          { item: 'scrap', quantity: 50 }, // Approximation of previous random logic, handled in death function
          { item: 'warp key', quantity: 1 }
        ];
      }
    }
    
    if (st.type === 'warpgate') {
        if (st.warpCost === undefined) st.warpCost = 3000;
        if (st.warpDestination === undefined) st.warpDestination = 'level2'; // Default
    }

    return st;
  });
  if (floatingOreContainer) while (floatingOreContainer.children.length) floatingOreContainer.remove(floatingOreContainer.children[0]);
  floatingItems.length = 0; // Clear floating items on level load
  pirates.length = 0; // Clear pirates on level load
  for (const st of structures) {
    if (st.type === 'piratebase') spawnBaseDefensePirates(st);
  }
  gameState.level.elapsedTime = 0;
  gameState.level.isDebug = levelData.debug === true;
  // Schedule first wave. (Non-debug uses spawnSettings.initialDelay.)
  gameState.level.pirateNextWaveTime = gameState.level.isDebug ? 5 : (gameState.level.spawnSettings.initialDelay || 0);
  
  // Regenerate stars: same density as a 3000x3000 level, using level seed for reproducibility
  gameState.level.seed = typeof levelData.seed === 'number' ? levelData.seed >>> 0 : 0;
  const rng = createSeededRandom(gameState.level.seed);
  const REFERENCE_AREA = 3000 * 3000;
  const numStars = Math.round(NUM_STARS * (gameState.level.width * gameState.level.height) / REFERENCE_AREA);
  stars.length = 0;
  const spread = Math.max(gameState.level.width, gameState.level.height) / 2;
  for (let i = 0; i < numStars; i++) {
    stars.push({
      x: (rng() - 0.5) * 2 * spread,
      y: (rng() - 0.5) * 2 * spread,
      size: rng() * 2 + 0.5,
      brightness: 0.3 + rng() * 0.7
    });
  }
  refreshAsteroidMeshes();
  refreshStructureMeshes();
  
  // Tutorial text: appears above player's starting position (timer starts on first thrust)
  gameState.ui.tutorialTextTimer = 11; // 10 seconds visible + 1 second fade
  gameState.ui.gameState.ui.tutorialTextTimerStarted = false;
  gameState.ui.tutorialTextWorldX = ship.x;
  gameState.ui.tutorialTextWorldY = ship.y - 80; // Above the ship
}

// Level select: scan known levels and populate dropdown
const KNOWN_LEVELS = [
  { name: 'Level 1', path: 'levels/level1.json' },
  { name: 'Level 2', path: 'levels/level2.json' },
  { name: 'Debug', path: 'levels/debug.json' }
];

const levelSelect = document.getElementById('level-select');
if (levelSelect) {
  KNOWN_LEVELS.forEach((lev, i) => {
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = lev.name;
    levelSelect.appendChild(opt);
  });
  levelSelect.addEventListener('change', () => {
    const lev = KNOWN_LEVELS[levelSelect.value];
    if (lev) {
      fetch(lev.path + '?t=' + Date.now())
        .then(res => res.json())
        .then(level => loadLevel(level))
        .catch(err => console.error('Failed to load ' + lev.path, err));
    }
  });
}

// Load initial level (Level 1)
fetch(KNOWN_LEVELS[0].path + '?t=' + Date.now())
  .then(res => res.json())
  .then(level => loadLevel(level))
  .catch(() => {});

function closeWarpMenu() {
  gameState.ui.warpMenuOpen = false;
  gameState.ui.paused = gameState.ui.warpMenuOpen || gameState.ui.shopMenuOpen || gameState.ui.craftingMenuOpen || gameState.ui.shipyardMenuOpen;
  const overlay = document.getElementById('warp-menu-overlay');
  if (overlay) overlay.style.display = 'none';
}

function openShopMenu(shopStructure) {
  if (gameState.ui.shopMenuOpen) return;
  
  gameState.ui.activeShopStructure = shopStructure;
  
  // Populate buy slots from structure inventory - expand by quantity
  shopBuySlots.fill(null);
  if (shopStructure && shopStructure.inventory) {
    let slotIndex = 0;
    for (const invItem of shopStructure.inventory) {
      const qty = invItem.quantity || 1;
      for (let q = 0; q < qty && slotIndex < shopBuySlots.length; q++) {
        const item = { ...invItem };
        delete item.quantity; // Remove quantity from individual slot item
        // Ensure containers are at full capacity with correct values
        if (item.item === 'small energy cell') { item.energy = 10; item.maxEnergy = 10; }
        else if (item.item === 'medium energy cell') { item.energy = 30; item.maxEnergy = 30; }
        else if (item.item === 'fuel tank') { item.fuel = 10; item.maxFuel = 10; }
        else if (item.item === 'large fuel tank') { item.fuel = 30; item.maxFuel = 30; }
        else if (item.item === 'oxygen canister') { item.oxygen = 10; item.maxOxygen = 10; }
        else if (item.item === 'large oxygen canister') { item.oxygen = 30; item.maxOxygen = 30; }
        else if (item.item === 'health pack') { item.health = 10; }
        else if (item.item === 'large health pack') { item.health = 30; }
        else if (item.maxFuel !== undefined) item.fuel = item.maxFuel;
        else if (item.maxOxygen !== undefined) item.oxygen = item.maxOxygen;
        shopBuySlots[slotIndex++] = item;
      }
    }
  }

  gameState.ui.paused = true;
  gameState.ui.shopMenuOpen = true;
  for (let i = 0; i < shopSellSlots.length; i++) shopSellSlots[i] = null;
  syncShopBuyArea();
  updateHUD();
  syncShopSellArea();
  const overlay = document.getElementById('shop-menu-overlay');
  if (overlay) overlay.style.display = 'flex';
  const ghost = document.getElementById('shop-drag-ghost');
  if (ghost) ghost.style.display = 'none';
  
  const creditsEl = document.getElementById('shop-credits-display');
  if (creditsEl) creditsEl.textContent = `You have ${player.credits} credits`;
}

function closeShopMenu() {
  returnSellAreaToHotbar();
  gameState.ui.shopMenuOpen = false;
  gameState.ui.paused = gameState.ui.warpMenuOpen || gameState.ui.shopMenuOpen || gameState.ui.craftingMenuOpen || gameState.ui.shipyardMenuOpen;
  inventoryDrag = null;
  gameState.ui.activeShopStructure = null;
  const overlay = document.getElementById('shop-menu-overlay');
  if (overlay) overlay.style.display = 'none';
  const ghost = document.getElementById('shop-drag-ghost');
  if (ghost) ghost.style.display = 'none';
  hideShopTooltip();
}

const warpMenuOverlay = document.getElementById('warp-menu-overlay');
const warpPayBtn = document.getElementById('warp-pay-btn');
const warpCancelBtn = document.getElementById('warp-cancel-btn');
if (warpCancelBtn) {
  warpCancelBtn.addEventListener('click', () => closeWarpMenu());
}
if (warpPayBtn) {
  warpPayBtn.addEventListener('click', () => {
    if (player.credits >= 3000) {
      player.credits -= 3000;
      closeWarpMenu();
    }
  });
}

const shopCloseBtn = document.getElementById('shop-close-btn');
if (shopCloseBtn) {
  shopCloseBtn.addEventListener('click', () => closeShopMenu());
}

const shopSellBtn = document.getElementById('shop-sell-btn');
if (shopSellBtn) {
  shopSellBtn.addEventListener('click', () => {
    const total = getSellTotal();
    if (total <= 0) return;
    player.credits += total;
    for (let i = 0; i < shopSellSlots.length; i++) shopSellSlots[i] = null;
    syncShopSellArea();
    updateHUD();
  });
}

// Crafting Menu Logic
function openCraftingMenu(structure) {
  if (gameState.ui.craftingMenuOpen) return;
  gameState.ui.activeCraftingStructure = structure;
  gameState.ui.craftingMenuOpen = true;
  gameState.ui.paused = true;
  
  // Clear slots
  for(let i=0; i<4; i++) gameState.ui.craftingInputSlots[i] = null;
  gameState.ui.craftingOutputSlot = null;
  
  // Render recipes list
  const list = document.getElementById('crafting-recipes-list');
  if (list) {
    list.innerHTML = '';
    if (structure.recipes) {
      structure.recipes.forEach(r => {
        const div = document.createElement('div');
        div.className = 'recipe-item';
        const inputs = r.inputs.map(i => `${i.quantity}x ${i.item}`).join(', ');
        div.textContent = `${inputs} -> ${r.output.quantity}x ${r.output.item}`;
        list.appendChild(div);
      });
    }
  }
  
  const overlay = document.getElementById('crafting-menu-overlay');
  if (overlay) overlay.style.display = 'flex';
  syncCraftingUI();
}

function closeCraftingMenu() {
  // Return items to inventory or drop them
  for(let i=0; i<4; i++) {
    if (gameState.ui.craftingInputSlots[i]) {
        if (!addToInventory(gameState.ui.craftingInputSlots[i].item, gameState.ui.craftingInputSlots[i].quantity)) {
             // Drop if full
             const it = gameState.ui.craftingInputSlots[i];
             const angle = Math.random() * Math.PI * 2;
             floatingItems.push({
               x: ship.x + Math.cos(angle) * 40,
               y: ship.y + Math.sin(angle) * 40,
               vx: Math.cos(angle) * 20,
               vy: Math.sin(angle) * 20,
               item: it.item,
               quantity: it.quantity,
               energy: it.energy, maxEnergy: it.maxEnergy,
               fuel: it.fuel, maxFuel: it.maxFuel,
               oxygen: it.oxygen, maxOxygen: it.maxOxygen
             });
        }
        gameState.ui.craftingInputSlots[i] = null;
    }
  }
  
  gameState.ui.craftingMenuOpen = false;
  gameState.ui.paused = gameState.ui.warpMenuOpen || gameState.ui.shopMenuOpen || gameState.ui.craftingMenuOpen || gameState.ui.shipyardMenuOpen;
  gameState.ui.activeCraftingStructure = null;
  const overlay = document.getElementById('crafting-menu-overlay');
  if (overlay) overlay.style.display = 'none';
  inventoryDrag = null;
}

function syncCraftingUI() {
    // Sync input slots
    for(let i=0; i<4; i++) {
        const el = document.querySelector(`.crafting-slot[data-craft-input="${i}"]`);
        if (el) {
            el.innerHTML = getSlotHTML(gameState.ui.craftingInputSlots[i]);
            el.classList.toggle('has-item', !!gameState.ui.craftingInputSlots[i]);
        }
    }
    // Sync output slot
    const outEl = document.getElementById('crafting-output-slot');
    if (outEl) {
        outEl.innerHTML = getSlotHTML(gameState.ui.craftingOutputSlot);
        outEl.classList.toggle('has-item', !!gameState.ui.craftingOutputSlot && gameState.ui.craftingOutputSlot.real);
        if (gameState.ui.craftingOutputSlot && !gameState.ui.craftingOutputSlot.real) outEl.style.opacity = '0.5';
        else outEl.style.opacity = '1';
    }
    
    // Check recipes
    checkCraftingRecipe();
}

function checkCraftingRecipe() {
    if (!gameState.ui.activeCraftingStructure || !gameState.ui.activeCraftingStructure.recipes) return;
    
    // If output is real (crafted but not taken), don't update preview
    if (gameState.ui.craftingOutputSlot && gameState.ui.craftingOutputSlot.real) {
        const btn = document.getElementById('craft-btn');
        if (btn) {
            btn.disabled = true;
            btn.textContent = 'Output Full';
        }
        return;
    }

    // Aggregate inputs
    const currentInputs = {};
    for(const slot of gameState.ui.craftingInputSlots) {
        if (slot) {
            currentInputs[slot.item] = (currentInputs[slot.item] || 0) + slot.quantity;
        }
    }
    
    let match = null;
    for (const r of gameState.ui.activeCraftingStructure.recipes) {
        let possible = true;
        for (const req of r.inputs) {
            if ((currentInputs[req.item] || 0) < req.quantity) {
                possible = false;
                break;
            }
        }
        if (possible) {
            match = r;
            break; 
        }
    }
    
    const btn = document.getElementById('craft-btn');
    if (match) {
        gameState.ui.craftingOutputSlot = { item: match.output.item, quantity: match.output.quantity, real: false };
        const payload = getShopItemPayload(match.output.item);
        Object.assign(gameState.ui.craftingOutputSlot, payload);
        
        if (btn) {
            btn.disabled = false;
            btn.textContent = 'Craft';
            btn.onclick = () => craftItem(match);
        }
    } else {
        gameState.ui.craftingOutputSlot = null;
        if (btn) {
            btn.disabled = true;
            btn.textContent = 'Craft';
            btn.onclick = null;
        }
    }
    
    // Re-render output slot to show ghost
    const outEl = document.getElementById('crafting-output-slot');
    if (outEl) {
        outEl.innerHTML = getSlotHTML(gameState.ui.craftingOutputSlot);
        if (gameState.ui.craftingOutputSlot && !gameState.ui.craftingOutputSlot.real) outEl.style.opacity = '0.5';
        else outEl.style.opacity = '1';
    }
}

function craftItem(recipe) {
    if (gameState.ui.craftingOutputSlot && gameState.ui.craftingOutputSlot.real) return;

    // Consume inputs
    // Deep copy inputs to avoid modifying recipe definition
    const inputsNeeded = recipe.inputs.map(i => ({...i}));
    
    for (const req of inputsNeeded) {
        let needed = req.quantity;
        for (let i=0; i<4; i++) {
            if (gameState.ui.craftingInputSlots[i] && gameState.ui.craftingInputSlots[i].item === req.item) {
                const take = Math.min(needed, gameState.ui.craftingInputSlots[i].quantity);
                gameState.ui.craftingInputSlots[i].quantity -= take;
                needed -= take;
                if (gameState.ui.craftingInputSlots[i].quantity <= 0) gameState.ui.craftingInputSlots[i] = null;
                if (needed <= 0) break;
            }
        }
    }
    
    // Set Output
    if (gameState.ui.craftingOutputSlot) {
        gameState.ui.craftingOutputSlot.real = true;
    }
    syncCraftingUI();
}

const craftingCloseBtn = document.getElementById('crafting-close-btn');
if (craftingCloseBtn) {
  craftingCloseBtn.addEventListener('click', () => closeCraftingMenu());
}

// Ship Definitions
const SHIP_STATS = {
  'scout': { name: 'Scout', price: 0, health: 50, fuel: 25, oxygen: 30, speed: 175, desc: 'Standard issue scout ship.' },
  'cutter': { name: 'Cutter', price: 5000, health: 80, fuel: 40, oxygen: 40, speed: 150, desc: 'Sturdy mining vessel with reinforced hull.' },
  'transport': { name: 'Transport', price: 12000, health: 120, fuel: 80, oxygen: 60, speed: 120, desc: 'Heavy transport with massive capacity.' }
};

let currentShipType = 'scout';

// Shipyard Menu Logic
function openShipyardMenu(structure) {
  if (gameState.ui.shipyardMenuOpen) return;
  gameState.ui.shipyardMenuOpen = true;
  gameState.ui.paused = true;
  
  const list = document.getElementById('shipyard-list');
  if (list) {
    list.innerHTML = '';
    const available = structure.availableShips || ['scout'];
    
    available.forEach(type => {
      const stats = SHIP_STATS[type];
      if (!stats) return;
      
      const div = document.createElement('div');
      div.className = 'ship-item';
      
      const info = document.createElement('div');
      info.className = 'ship-info';
      info.innerHTML = `<h4>${stats.name}</h4><p>${stats.desc}</p><p>HP: ${stats.health} | Fuel: ${stats.fuel} | O2: ${stats.oxygen} | Spd: ${stats.speed}</p>`;
      
      const btn = document.createElement('button');
      btn.className = 'ship-buy-btn';
      
      if (currentShipType === type) {
        btn.textContent = 'Owned';
        btn.classList.add('owned');
        btn.disabled = true;
      } else {
        btn.textContent = `Buy (${stats.price} cr)`;
        if (player.credits < stats.price) btn.disabled = true;
        btn.onclick = () => buyShip(type);
      }
      
      div.appendChild(info);
      div.appendChild(btn);
      list.appendChild(div);
    });
  }
  
  const creditsEl = document.getElementById('shipyard-credits');
  if (creditsEl) creditsEl.textContent = `You have ${player.credits} credits`;
  
  const overlay = document.getElementById('shipyard-menu-overlay');
  if (overlay) overlay.style.display = 'flex';
}

function closeShipyardMenu() {
  gameState.ui.shipyardMenuOpen = false;
  gameState.ui.paused = gameState.ui.warpMenuOpen || gameState.ui.shopMenuOpen || gameState.ui.craftingMenuOpen || gameState.ui.shipyardMenuOpen;
  const overlay = document.getElementById('shipyard-menu-overlay');
  if (overlay) overlay.style.display = 'none';
}

function buyShip(type) {
  const stats = SHIP_STATS[type];
  if (!stats) return;
  if (player.credits < stats.price) return;
  
  player.credits -= stats.price;
  currentShipType = type;
  
  // Update player stats to match new ship (heal to full)
  player.maxHealth = stats.health;
  player.health = stats.health;
  player.maxFuel = stats.fuel;
  player.fuel = stats.fuel;
  player.maxOxygen = stats.oxygen;
  player.oxygen = stats.oxygen;
  
  // Update physics constants
  MAX_SPEED = stats.speed;
  
  // Refresh menu
  const list = document.getElementById('shipyard-list');
  // Re-open to refresh
  const overlay = document.getElementById('shipyard-menu-overlay');
  if (overlay) overlay.style.display = 'none';
  // We need the structure reference to re-open... 
  // Actually simpler to just close it.
  closeShipyardMenu();
  alert(`Purchased ${stats.name}!`);
  updateHUD();
}

const shipyardCloseBtn = document.getElementById('shipyard-close-btn');
if (shipyardCloseBtn) {
  shipyardCloseBtn.addEventListener('click', () => closeShipyardMenu());
}

// Shop item tooltip
const ITEM_USAGE = {
  'small energy cell': 'Powers mining lasers and blasters.',
  'medium energy cell': 'Powers mining lasers and blasters. Holds 3x more charge.',
  'fuel tank': 'Drag to fuel bar to refill ship fuel.',
  'large fuel tank': 'Large capacity fuel tank.',
  'oxygen canister': 'Drag to O2 bar to refill ship oxygen.',
  'large oxygen canister': 'Large capacity oxygen canister.',
  'health pack': 'Drag to health bar to repair ship.',
  'large health pack': 'Large capacity repair kit.',
  'light blaster': 'Select and left-click to fire rapid projectiles at enemies.',
  'mining laser': 'Select and left-click to mine asteroids for ore.',
  'medium mining laser': 'Upgraded laser that mines faster.',
  'cuprite': 'Common ore. Sell at shops for credits.',
  'hematite': 'Uncommon ore. Worth more than cuprite.',
  'aurite': 'Rare golden ore. Valuable at shops.',
  'diamite': 'Precious ore. High value.',
  'platinite': 'Extremely rare ore. Most valuable.',
  'scrap': 'Salvaged material. Can be sold for credits.',
  'warp key': 'Required to activate warp gates.'
};

const ITEM_DISPLAY_NAMES = {
  'small energy cell': 'Small Energy Cell',
  'medium energy cell': 'Medium Energy Cell',
  'fuel tank': 'Fuel Tank',
  'large fuel tank': 'Large Fuel Tank',
  'oxygen canister': 'Oxygen Canister',
  'large oxygen canister': 'Large Oxygen Canister',
  'health pack': 'Health Pack',
  'large health pack': 'Large Health Pack',
  'light blaster': 'Light Blaster',
  'mining laser': 'Mining Laser',
  'medium mining laser': 'Medium Mining Laser',
  'cuprite': 'Cuprite',
  'hematite': 'Hematite',
  'aurite': 'Aurite',
  'diamite': 'Diamite',
  'platinite': 'Platinite',
  'scrap': 'Scrap',
  'warp key': 'Warp Key'
};

function showShopTooltip(itemKey, price, isBuy, slotEl) {
  const tooltip = document.getElementById('shop-item-tooltip');
  if (!tooltip || !itemKey) return;
  const name = ITEM_DISPLAY_NAMES[itemKey] || itemKey;
  const usage = ITEM_USAGE[itemKey] || '';
  const priceText = isBuy ? `Buy: ${price} cr` : `Sell: ${price} cr`;
  tooltip.innerHTML = `<div class="tooltip-name">${name}</div><div class="tooltip-price">${priceText}</div><div class="tooltip-usage">${usage}</div>`;
  tooltip.style.display = 'block';
  // Position above the slot
  const rect = slotEl.getBoundingClientRect();
  const overlay = document.getElementById('shop-menu-overlay');
  const overlayRect = overlay ? overlay.getBoundingClientRect() : { left: 0, top: 0 };
  const left = rect.left - overlayRect.left + rect.width / 2 - 110;
  const top = rect.top - overlayRect.top - tooltip.offsetHeight - 8;
  tooltip.style.left = Math.max(10, left) + 'px';
  tooltip.style.top = Math.max(10, top) + 'px';
}

function hideShopTooltip() {
  const tooltip = document.getElementById('shop-item-tooltip');
  if (tooltip) tooltip.style.display = 'none';
}

// Add hover listeners for shop slots
document.querySelectorAll('.shop-buy-slot').forEach(el => {
  el.addEventListener('mouseenter', () => {
    const idx = parseInt(el.dataset.buySlot, 10);
    const it = shopBuySlots[idx];
    if (it) {
      const price = getItemBuyPrice(it.item);
      showShopTooltip(it.item, price, true, el);
    }
  });
  el.addEventListener('mouseleave', hideShopTooltip);
});

document.querySelectorAll('.shop-sell-slot').forEach(el => {
  el.addEventListener('mouseenter', () => {
    const idx = parseInt(el.dataset.sellSlot, 10);
    const it = shopSellSlots[idx];
    if (it) {
      const price = getItemSellPrice(it);
      showShopTooltip(it.item, price, false, el);
    }
  });
  el.addEventListener('mouseleave', hideShopTooltip);
});

function showHotbarTooltip(it, slotEl) {
  const tooltip = document.getElementById('hotbar-item-tooltip');
  if (!tooltip || !it || !it.item) return;
  const name = ITEM_DISPLAY_NAMES[it.item] || it.item;
  const usage = ITEM_USAGE[it.item] || '';
  const sellPrice = getItemSellPrice(it);
  const priceHtml = sellPrice > 0 ? `<div class="tooltip-price">Sell: ${sellPrice} cr</div>` : '';
  tooltip.innerHTML = `<div class="tooltip-name">${name}</div>${priceHtml}<div class="tooltip-usage">${usage}</div>`;
  tooltip.style.display = 'block';
  const rect = slotEl.getBoundingClientRect();
  const overlay = document.getElementById('hud-overlay');
  const overlayRect = overlay ? overlay.getBoundingClientRect() : { left: 0, top: 0, width: 360 };
  const tooltipW = 220;
  const left = rect.left - overlayRect.left + rect.width / 2 - tooltipW / 2;
  const top = rect.top - overlayRect.top - tooltip.offsetHeight - 8;
  tooltip.style.left = Math.max(8, Math.min(left, (overlayRect.width || 360) - tooltipW - 8)) + 'px';
  tooltip.style.top = top + 'px';
}

function hideHotbarTooltip() {
  const tooltip = document.getElementById('hotbar-item-tooltip');
  if (tooltip) tooltip.style.display = 'none';
}

document.querySelectorAll('#hotbar .slot').forEach(el => {
  el.addEventListener('mouseenter', () => {
    const slotIndex = parseInt(el.dataset.slot, 10);
    const it = hotbar[slotIndex];
    if (it) showHotbarTooltip(it, el);
  });
  el.addEventListener('mouseleave', hideHotbarTooltip);
});

// Inventory drag state (unified for HUD and Shop)
let inventoryDrag = null; // { kind: 'hotbar'|'buy'|'sell', fromSlot?: number, fromBuySlot?: number, fromSellSlot?: number, price?: number }

function setDragGhostVisible(visible) {
  const ghost = document.getElementById('shop-drag-ghost');
  if (!ghost) return;
  ghost.style.display = visible ? 'flex' : 'none';
}

function setDragGhostContent(it, label, qtyText) {
  const ghost = document.getElementById('shop-drag-ghost');
  if (!ghost) return;
  const imgPath = it ? getItemImagePath(it.item) : null;
  if (imgPath) {
    if (qtyText) {
      ghost.innerHTML = `<img src="${imgPath}" alt=""><span class="slot-qty">${qtyText}</span>`;
    } else {
      ghost.innerHTML = `<img src="${imgPath}" alt="">`;
    }
  } else {
    if (qtyText) {
      ghost.innerHTML = `${label}<span class="slot-qty">${qtyText}</span>`;
    } else {
      ghost.textContent = label;
    }
  }
}

function setDragGhostPos(clientX, clientY) {
  const ghost = document.getElementById('shop-drag-ghost');
  if (!ghost) return;
  ghost.style.left = (clientX - 22) + 'px';
  ghost.style.top = (clientY - 22) + 'px';
}

function beginDragFromHotbar(slotIndex, clientX, clientY) {
  const it = hotbar[slotIndex];
  if (!it) return;
  hideShopTooltip();
  inventoryDrag = { kind: 'hotbar', fromSlot: slotIndex };
  const qty = it.quantity != null ? String(it.quantity) : (it.energy != null ? String(Math.round(it.energy)) : (it.fuel != null ? String(Math.round(it.fuel)) : (it.oxygen != null ? String(Math.round(it.oxygen)) : (it.heat != null ? String(Math.round(it.heat * 100)) : ''))));
  setDragGhostContent(it, getItemLabel(it), qty);
  setDragGhostPos(clientX, clientY);
  setDragGhostVisible(true);
}

function beginDragFromBuy(buyIndex, clientX, clientY) {
  const it = shopBuySlots[buyIndex];
  if (!it) return;
  hideShopTooltip();
  const price = getItemBuyPrice(it.item);
  inventoryDrag = { kind: 'buy', fromBuySlot: buyIndex, price };
  const qty = it.quantity != null ? String(it.quantity) : (it.energy != null ? String(Math.round(it.energy)) : (it.fuel != null ? String(Math.round(it.fuel)) : (it.oxygen != null ? String(Math.round(it.oxygen)) : (it.heat != null ? String(Math.round(it.heat * 100)) : ''))));
  setDragGhostContent(it, getItemLabel(it), qty);
  setDragGhostPos(clientX, clientY);
  setDragGhostVisible(true);
}

function beginDragFromSell(sellIndex, clientX, clientY) {
  const it = shopSellSlots[sellIndex];
  if (!it) return;
  hideShopTooltip();
  inventoryDrag = { kind: 'sell', fromSellSlot: sellIndex };
  const qty = it.quantity != null ? String(it.quantity) : (it.energy != null ? String(Math.round(it.energy)) : (it.fuel != null ? String(Math.round(it.fuel)) : (it.oxygen != null ? String(Math.round(it.oxygen)) : (it.heat != null ? String(Math.round(it.heat * 100)) : ''))));
  setDragGhostContent(it, getItemLabel(it), qty);
  setDragGhostPos(clientX, clientY);
  setDragGhostVisible(true);
}

function endDrag(clientX, clientY) {
  const drag = inventoryDrag;
  inventoryDrag = null;
  setDragGhostVisible(false);
  // Remove fuel and O2 bar highlights
  const fuelBarEl = document.getElementById('fuel-bar-drop-zone');
  if (fuelBarEl) fuelBarEl.classList.remove('highlight');
  const oxygenBarEl = document.getElementById('oxygen-bar-drop-zone');
  if (oxygenBarEl) oxygenBarEl.classList.remove('highlight');
  const healthBarEl = document.getElementById('health-bar-drop-zone');
  if (healthBarEl) healthBarEl.classList.remove('highlight');
  if (!drag) return;

  const under = document.elementFromPoint(clientX, clientY);
  let targetSlotEl = null;
  const isOverFuelBar = under && under.closest('#fuel-bar-drop-zone');
  const isOverO2Bar = under && under.closest('#oxygen-bar-drop-zone');
  const isOverHealthBar = under && under.closest('#health-bar-drop-zone');
  if (under) {
    targetSlotEl = under.closest('.slot') || under.closest('.shop-buy-slot') || under.closest('.shop-sell-slot');
  }

  // Handle drop on O2 bar
  if (isOverO2Bar && drag.kind === 'hotbar') {
    const from = drag.fromSlot;
    const it = hotbar[from];
    if (it && (it.item === 'oxygen canister' || it.item === 'large oxygen canister')) {
      const addAmount = it.oxygen !== undefined ? it.oxygen : 10;
      player.oxygen = Math.min(player.maxOxygen, player.oxygen + addAmount);
      hotbar[from] = null;
      updateHUD();
      return;
    }
  }

  // Handle drop on fuel bar
  if (isOverFuelBar && drag.kind === 'hotbar') {
    const from = drag.fromSlot;
    const it = hotbar[from];
    if (it && (it.item === 'fuel tank' || it.item === 'large fuel tank')) {
      const addAmount = it.fuel !== undefined ? it.fuel : 10;
      player.fuel = Math.min(player.maxFuel, player.fuel + addAmount);
      hotbar[from] = null;
      updateHUD();
      return;
    }
  }

  // Handle drop on health bar
  if (isOverHealthBar && drag.kind === 'hotbar') {
    const from = drag.fromSlot;
    const it = hotbar[from];
    if (it && (it.item === 'health pack' || it.item === 'large health pack')) {
      const addAmount = it.health !== undefined ? it.health : 10;
      player.health = Math.min(player.maxHealth, player.health + addAmount);
      hotbar[from] = null;
      updateHUD();
      return;
    }
  }

  // Handle drop on O2 bar from buy slot
  if (isOverO2Bar && drag.kind === 'buy') {
    const from = drag.fromBuySlot;
    const it = shopBuySlots[from];
    if (it && (it.item === 'oxygen canister' || it.item === 'large oxygen canister')) {
      const price = drag.price;
      if (player.credits >= price) {
        player.credits -= price;
        const addAmount = it.oxygen !== undefined ? it.oxygen : 10;
        player.oxygen = Math.min(player.maxOxygen, player.oxygen + addAmount);
        removeFromShopInventory(it.item);
        shopBuySlots[from] = null;
        syncShopBuyArea();
        updateHUD();
        const creditsEl = document.getElementById('shop-credits-display');
        if (creditsEl) creditsEl.textContent = `You have ${player.credits} credits`;
      }
      return;
    }
  }

  // Handle drop on fuel bar from buy slot
  if (isOverFuelBar && drag.kind === 'buy') {
    const from = drag.fromBuySlot;
    const it = shopBuySlots[from];
    if (it && (it.item === 'fuel tank' || it.item === 'large fuel tank')) {
      const price = drag.price;
      if (player.credits >= price) {
        player.credits -= price;
        const addAmount = it.fuel !== undefined ? it.fuel : 10;
        player.fuel = Math.min(player.maxFuel, player.fuel + addAmount);
        removeFromShopInventory(it.item);
        shopBuySlots[from] = null;
        syncShopBuyArea();
        updateHUD();
        const creditsEl = document.getElementById('shop-credits-display');
        if (creditsEl) creditsEl.textContent = `You have ${player.credits} credits`;
      }
      return;
    }
  }

  // Handle drop on health bar from buy slot
  if (isOverHealthBar && drag.kind === 'buy') {
    const from = drag.fromBuySlot;
    const it = shopBuySlots[from];
    if (it && (it.item === 'health pack' || it.item === 'large health pack')) {
      const price = drag.price;
      if (player.credits >= price) {
        player.credits -= price;
        const addAmount = it.health !== undefined ? it.health : 10;
        player.health = Math.min(player.maxHealth, player.health + addAmount);
        removeFromShopInventory(it.item);
        shopBuySlots[from] = null;
        syncShopBuyArea();
        updateHUD();
        const creditsEl = document.getElementById('shop-credits-display');
        if (creditsEl) creditsEl.textContent = `You have ${player.credits} credits`;
      }
      return;
    }
  }

  // Handle Jettison if dropped outside of UI and shop is closed
  if (!targetSlotEl && !gameState.ui.shopMenuOpen && !gameState.ui.craftingMenuOpen && !gameState.ui.shipyardMenuOpen && drag.kind === 'hotbar') {
    // Drop into space
    const from = drag.fromSlot;
    const it = hotbar[from];
    if (it) {
      const dx = inputManager.mouse.x - WIDTH / 2;
      const dy = inputManager.mouse.y - HEIGHT / 2;
      const dir = normalize(dx, dy);
      if (dir.x !== 0 || dir.y !== 0) {
        const jettSpeed = 340;
        const totalQty = it.quantity || 1;
        const baseAngle = Math.atan2(dir.y, dir.x);
        
        for (let i = 0; i < totalQty; i++) {
            // Small spread: +/- 0.25 rad (~14 deg) for burst effect
            const spread = (Math.random() - 0.5) * 0.5; 
            const angle = baseAngle + spread;
            const speedVar = 0.8 + Math.random() * 0.4; // +/- 20% speed variation
            const jVx = Math.cos(angle) * jettSpeed * speedVar;
            const jVy = Math.sin(angle) * jettSpeed * speedVar;

            const floatItem = {
              x: ship.x + Math.cos(angle) * 20,
              y: ship.y + Math.sin(angle) * 20,
              vx: jVx + ship.vx * 0.3,
              vy: jVy + ship.vy * 0.3,
              item: it.item,
              quantity: 1
            };
            if (it.energy != null) {
              floatItem.energy = it.energy;
              floatItem.maxEnergy = it.maxEnergy;
            }
            if (it.fuel != null) {
              floatItem.fuel = it.fuel;
              floatItem.maxFuel = it.maxFuel;
            }
            if (it.oxygen != null) {
              floatItem.oxygen = it.oxygen;
              floatItem.maxOxygen = it.maxOxygen;
            }
            if (it.heat != null) {
              floatItem.heat = it.heat;
              floatItem.overheated = !!it.overheated;
            }
            floatingItems.push(floatItem);
        }
        hotbar[from] = null;
        updateHUD();
      }
    }
    return;
  }

  if (!targetSlotEl) return;

  // Determine target type
  const isHotbar = targetSlotEl.classList.contains('slot');
  const isSell = targetSlotEl.classList.contains('shop-sell-slot');
  const isBuy = targetSlotEl.classList.contains('shop-buy-slot'); // Can't drop onto buy slots generally
  const isCraftInput = targetSlotEl.classList.contains('input-slot');
  const isCraftOutput = targetSlotEl.classList.contains('output-slot');

  if (drag.kind === 'hotbar') {
    const from = drag.fromSlot;
    const it = hotbar[from];
    if (!it) return;

    if (isSell && gameState.ui.shopMenuOpen) {
      const sellIndex = parseInt(targetSlotEl.dataset.sellSlot, 10);
      if (sellIndex >= 0 && !shopSellSlots[sellIndex]) {
        shopSellSlots[sellIndex] = { ...it };
        hotbar[from] = null;
        updateHUD();
        syncShopSellArea();
        return;
      }
    } else if (isCraftInput && gameState.ui.craftingMenuOpen) {
      const idx = parseInt(targetSlotEl.dataset.craftInput, 10);
      if (idx >= 0 && !gameState.ui.craftingInputSlots[idx]) {
        gameState.ui.craftingInputSlots[idx] = { ...it };
        hotbar[from] = null;
        updateHUD();
        syncCraftingUI();
        return;
      }
    } else if (isHotbar) {
      const to = parseInt(targetSlotEl.dataset.slot, 10);
      if (to >= 0 && to !== from) {
        const tmp = hotbar[to];
        hotbar[to] = hotbar[from];
        hotbar[from] = tmp;
        updateHUD();
        return;
      }
    }
  } else if (drag.kind === 'buy') {
    if (!isHotbar) return;
    const from = drag.fromBuySlot;
    const it = shopBuySlots[from];
    if (!it) return;
    const to = parseInt(targetSlotEl.dataset.slot, 10);
    if (to < 0) return;
    if (hotbar[to]) return;
    if (player.credits < drag.price) return;
    player.credits -= drag.price;
    hotbar[to] = { ...it };
    removeFromShopInventory(it.item);
    shopBuySlots[from] = null;
    syncShopBuyArea();
    updateHUD();
  } else if (drag.kind === 'sell') {
    const from = drag.fromSellSlot;
    const it = shopSellSlots[from];
    if (!it) return;
    
    if (isHotbar) {
      const to = parseInt(targetSlotEl.dataset.slot, 10);
      if (to >= 0 && !hotbar[to]) {
        hotbar[to] = { ...it };
        shopSellSlots[from] = null;
        updateHUD();
        syncShopSellArea();
        return;
      }
    } else if (isSell) {
      const toSell = parseInt(targetSlotEl.dataset.sellSlot, 10);
      if (toSell >= 0 && toSell !== from) {
        const tmp = shopSellSlots[toSell];
        shopSellSlots[toSell] = shopSellSlots[from];
        shopSellSlots[from] = tmp;
        syncShopSellArea();
        return;
      }
    }
  } else if (drag.kind === 'craftInput') {
    const from = drag.fromCraftInput;
    const it = gameState.ui.craftingInputSlots[from];
    if (!it) return;
    
    if (isHotbar) {
      const to = parseInt(targetSlotEl.dataset.slot, 10);
      if (to >= 0 && !hotbar[to]) {
        hotbar[to] = { ...it };
        gameState.ui.craftingInputSlots[from] = null;
        updateHUD();
        syncCraftingUI();
        return;
      }
    } else if (isCraftInput) {
      const to = parseInt(targetSlotEl.dataset.craftInput, 10);
      if (to >= 0 && to !== from) {
        const tmp = gameState.ui.craftingInputSlots[to];
        gameState.ui.craftingInputSlots[to] = gameState.ui.craftingInputSlots[from];
        gameState.ui.craftingInputSlots[from] = tmp;
        syncCraftingUI();
        return;
      }
    }
  } else if (drag.kind === 'craftOutput') {
    const it = gameState.ui.craftingOutputSlot;
    if (!it || !it.real) return;
    
    if (isHotbar) {
      const to = parseInt(targetSlotEl.dataset.slot, 10);
      if (to >= 0 && !hotbar[to]) {
        hotbar[to] = { ...it };
        // Clear output slot
        gameState.ui.craftingOutputSlot = null;
        updateHUD();
        syncCraftingUI();
        return;
      }
    }
  }
}

// UI Drag Start Listener
window.addEventListener('mousedown', (e) => {
  if (e.button !== 0) return;
  const t = e.target;
  
  const hotbarSlotEl = t.closest && t.closest('#hotbar .slot');
  const buySlotEl = t.closest && t.closest('.shop-buy-slot');
  const sellSlotEl = t.closest && t.closest('.shop-sell-slot');
  const craftInputEl = t.closest && t.closest('.crafting-slot.input-slot');
  const craftOutputEl = t.closest && t.closest('.crafting-slot.output-slot');
  
  if (hotbarSlotEl) {
    const slotIndex = parseInt(hotbarSlotEl.dataset.slot, 10);
    if (slotIndex >= 0 && hotbar[slotIndex]) {
      e.preventDefault();
      // Shift+click (with shop open): transfer item to first empty sell slot
      if (e.shiftKey && gameState.ui.shopMenuOpen) {
        const it = hotbar[slotIndex];
        const firstEmpty = shopSellSlots.findIndex(s => !s);
        if (firstEmpty >= 0) {
          shopSellSlots[firstEmpty] = { ...it };
          hotbar[slotIndex] = null;
          syncShopSellArea();
          updateHUD();
        }
        return;
      }
      // Shift+click (with crafting open): transfer to first empty input slot
      if (e.shiftKey && gameState.ui.craftingMenuOpen) {
        const it = hotbar[slotIndex];
        const firstEmpty = gameState.ui.craftingInputSlots.findIndex(s => !s);
        if (firstEmpty >= 0) {
          gameState.ui.craftingInputSlots[firstEmpty] = { ...it };
          hotbar[slotIndex] = null;
          syncCraftingUI();
          updateHUD();
        }
        return;
      }
      beginDragFromHotbar(slotIndex, e.clientX, e.clientY);
    }
    return;
  }
  
  if (gameState.ui.shopMenuOpen) {
    if (buySlotEl) {
      const buyIndex = parseInt(buySlotEl.dataset.buySlot, 10);
      if (buyIndex >= 0 && shopBuySlots[buyIndex]) {
        e.preventDefault();
        beginDragFromBuy(buyIndex, e.clientX, e.clientY);
      }
      return;
    }
    if (sellSlotEl) {
      const sellIndex = parseInt(sellSlotEl.dataset.sellSlot, 10);
      if (sellIndex >= 0 && shopSellSlots[sellIndex]) {
        e.preventDefault();
        beginDragFromSell(sellIndex, e.clientX, e.clientY);
      }
      return;
    }
  }

  if (gameState.ui.craftingMenuOpen) {
    if (craftInputEl) {
      const idx = parseInt(craftInputEl.dataset.craftInput, 10);
      if (idx >= 0 && gameState.ui.craftingInputSlots[idx]) {
        e.preventDefault();
        // Shift+click: return to inventory
        if (e.shiftKey) {
            if (addToInventory(gameState.ui.craftingInputSlots[idx].item, gameState.ui.craftingInputSlots[idx].quantity)) {
                gameState.ui.craftingInputSlots[idx] = null;
                syncCraftingUI();
                updateHUD();
            }
            return;
        }
        // Drag
        hideShopTooltip();
        const it = gameState.ui.craftingInputSlots[idx];
        inventoryDrag = { kind: 'craftInput', fromCraftInput: idx };
        const qty = it.quantity != null ? String(it.quantity) : '';
        setDragGhostContent(it, getItemLabel(it), qty);
        setDragGhostPos(e.clientX, e.clientY);
        setDragGhostVisible(true);
      }
      return;
    }
    if (craftOutputEl) {
      if (gameState.ui.craftingOutputSlot && gameState.ui.craftingOutputSlot.real) {
        e.preventDefault();
        if (e.shiftKey) {
            if (addToInventory(gameState.ui.craftingOutputSlot.item, gameState.ui.craftingOutputSlot.quantity)) {
                gameState.ui.craftingOutputSlot = null;
                syncCraftingUI();
                updateHUD();
            }
            return;
        }
        // Drag
        hideShopTooltip();
        const it = gameState.ui.craftingOutputSlot;
        inventoryDrag = { kind: 'craftOutput' };
        const qty = it.quantity != null ? String(it.quantity) : '';
        setDragGhostContent(it, getItemLabel(it), qty);
        setDragGhostPos(e.clientX, e.clientY);
        setDragGhostVisible(true);
      }
      return;
    }
  }
});

window.addEventListener('mousemove', (e) => {
  if (inventoryDrag) {
    setDragGhostPos(e.clientX, e.clientY);
    const fuelBarEl = document.getElementById('fuel-bar-drop-zone');
    const oxygenBarEl = document.getElementById('oxygen-bar-drop-zone');
    const healthBarEl = document.getElementById('health-bar-drop-zone');
    const under = document.elementFromPoint(e.clientX, e.clientY);
    
    let it = null;
    if (inventoryDrag.kind === 'hotbar') {
      it = hotbar[inventoryDrag.fromSlot];
    } else if (inventoryDrag.kind === 'buy') {
      it = shopBuySlots[inventoryDrag.fromBuySlot];
    } else if (inventoryDrag.kind === 'craftInput') {
      it = gameState.ui.craftingInputSlots[inventoryDrag.fromCraftInput];
    } else if (inventoryDrag.kind === 'craftOutput') {
      it = gameState.ui.craftingOutputSlot;
    }
    
    const isOverFuel = under && under.closest('#fuel-bar-drop-zone');
    const isOverO2 = under && under.closest('#oxygen-bar-drop-zone');
    const isOverHealth = under && under.closest('#health-bar-drop-zone');
    
    // Highlight fuel bar
    const showFuelHighlight = it && (it.item === 'fuel tank' || it.item === 'large fuel tank') && isOverFuel;
    if (fuelBarEl) fuelBarEl.classList.toggle('highlight', showFuelHighlight);
    
    // Highlight O2 bar
    const showO2Highlight = it && (it.item === 'oxygen canister' || it.item === 'large oxygen canister') && isOverO2;
    if (oxygenBarEl) oxygenBarEl.classList.toggle('highlight', showO2Highlight);

    // Highlight Health bar
    const showHealthHighlight = it && (it.item === 'health pack' || it.item === 'large health pack') && isOverHealth;
    if (healthBarEl) healthBarEl.classList.toggle('highlight', showHealthHighlight);
  }
});

window.addEventListener('mouseup', (e) => {
  if (e.button !== 0) return;
  if (inventoryDrag) {
    endDrag(e.clientX, e.clientY);
  }
});

// Game loop
let lastTime = performance.now();
initStars();
initShopBuySlots();
initShip3D();

// Initial level load is handled at startup (level1.json)

function gameLoop(now) {
  const dt = Math.min((now - lastTime) / 1000, 0.1);
  lastTime = now;

  if (!gameState.ui.paused) update(dt);
  render(gameState.ui.paused ? 0 : dt);
  updateHUD(); // Sync HUD every frame (or could optimize to only when changed)

  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

```

